{"data":{"site":{"siteMetadata":{"blurb":"Frontend Engineer @ LaunchDarkly. Book addict and tea lover. Passionate about react graphql and making things fast."}},"markdownRemark":{"html":"<p>Kubernetes rocks. Kubernetes engine to be exact. I was so inspired by Kelsey Hightower's\n<a href=\"https://www.youtube.com/watch?v=kOa_llowQ1c&#x26;feature=youtu.be\" target=\"_blank\" rel=\"nofollow\">presentation</a> at KubeCon 2017 I\nspent the next 2 weeks migrating my entire pipeline from Jenkins/AWS/Terraform to Google Cloud Platform (GCP for short)\nand the Kubernetes Engine. It's the best decision I have ever made.</p>\n<p>Ok so the title is a little dramatic. Kubernetes uses docker so it doesn't actually really kill docker, it merely pushes\nit further into the background. That means you are free to focus on the bigger picture, which is your end to end pipeline\nand your code. During my migration, I found that apart from the dockerfile and a docker build, I didn't really have to\ntouch docker much. It's a sign that the docker stack has matured.</p>\n<p>In this blog I'll walk you through how to set up a continuous dev pipeline on GCP and the Kubernetes Engine.   </p>\n<h2 id=\"goal\"><a href=\"#goal\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Goal</h2>\n<p>During development, the dev test cycle is predictable and well-defined. You write code, it runs locally and pass all the\ntests then you push your code to git. The <em>intent</em> is clear. Pushing to git means you want to see that code running on an\nenvironment somewhere. This environment should also be predictable and well-defined. Without doing any more work, you\nshould be able to open your browser and run the code you just pushed in this well-defined environment.</p>\n<p>The goal of this tutorial is to build a pipeline that does exactly that. At the end of this post, you should be able to:</p>\n<ol>\n<li>Create a new feature off master, code and test locally.</li>\n<li>Push to git.</li>\n<li>Browse to a well-defined feature url which has the new code running.</li>\n</ol>\n<h2 id=\"step-1-create-a-kubernetes-cluster\"><a href=\"#step-1-create-a-kubernetes-cluster\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 1: Create a Kubernetes cluster</h2>\n<p>Jump into google cloud console and under the main menu, go to Compute -> Kubernetes Engine -> Kubernetes clusters and\nclick on Create Cluster. You'll see a screen like below, you only need to touch 3 fields:</p>\n<img alt=\"Create Kubernetes cluster\" src=\"/static/create-cluster-9306cce2e0bd30f103995b3bb9124bdd.png\" id=\"markdownImage\"/>\n<ol>\n<li>\n<p>Name your cluster <em>feature-cluster</em>. When we push to git, we'll deploy our feature to nodes running on this cluster.</p>\n</li>\n<li>\n<p>Pick a zone that's closest to you. The Zonal and Regional option refers to the location of your Kubernetes master.\nZonal means your master service will be running in a single zone that you picked. Regional means your master service\nwill be running in multiple zones in that region for redundancy. To keep things simple for this demo we'll stick with zonal.</p>\n</li>\n<li>\n<p>Pick the latest cluster version to get all the latest features.</p>\n</li>\n</ol>\n<p>Leave the remaining default settings e.g. 3 nodes in the cluster on Container-Optimised OS and click create. It takes\nsome time for google to create your cluster because it has to provision the nodes. While that's cooking, we'll create\nthe build job.</p>\n<h2 id=\"step-2-create-a-build-trigger\"><a href=\"#step-2-create-a-build-trigger\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 2: Create a build trigger</h2>\n<p>In the console menu, go to Tools -> Container Registry -> Build triggers. Add a new trigger. Select your git source\n(I use github) and repo and authorise container builder to access it. Then you'll get to the\nEdit Trigger page like below:</p>\n<img alt=\"Container builder trigger settings\" src=\"/static/create-trigger-2c35c3d8e6b0765c67b495875dc6c5e4.png\" id=\"markdownImage\"/>\n<ol>\n<li>\n<p>Give your trigger a name, I name mine <em>feature</em> because it gets triggered by a feature push and builds and deploys\nthat feature.</p>\n</li>\n<li>\n<p>Set the trigger type to branch, because we want to trigger a build when a feature branch push happens. There is also\nan option to trigger on tag push, which is useful for production deployment (when you create a release tag) but we'll\ncover that in a future post.</p>\n</li>\n<li>\n<p>Set a regex to match the feature branch names. By convention I enforce the following convention for features:\nfeature-[JIRA<em>TICKET</em>NUMBER]-description. All the developers follow this naming convention when they create a new\nfeature branch. Once a convention is in place, you can set a regex expression here to match your feature branches.</p>\n</li>\n<li>\n<p>You define your build steps in the cloudbuild.yaml file. Set the location of <em>cloudbuild.yaml</em> so container builder\ncan find it in your repo. I set mine to the root of my repo.</p>\n</li>\n</ol>\n<h2 id=\"step-3-cloudbuildyaml\"><a href=\"#step-3-cloudbuildyaml\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 3: cloudbuild.yaml</h2>\n<p>Container builder uses this file to execute a series of steps to build and deploy your app. Each build step specified\nhere is a container running in its own shell. For our demo, we'll use the cloudbuild.yaml below:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> ubuntu\n  <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> generate<span class=\"token punctuation\">-</span>image<span class=\"token punctuation\">-</span>tag\n  <span class=\"token key atrule\">entrypoint</span><span class=\"token punctuation\">:</span> bash\n  <span class=\"token key atrule\">args</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token string\">'-c'</span>\n  <span class=\"token punctuation\">-</span> echo $(date) <span class=\"token punctuation\">|</span> md5sum <span class=\"token punctuation\">|</span> awk '<span class=\"token punctuation\">{</span>print $1<span class=\"token punctuation\">}</span>' <span class=\"token punctuation\">></span> tag.txt\n\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> gcr.io/cloud<span class=\"token punctuation\">-</span>builders/docker\n  <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> docker<span class=\"token punctuation\">-</span>build<span class=\"token punctuation\">-</span>push\n  <span class=\"token key atrule\">entrypoint</span><span class=\"token punctuation\">:</span> bash\n  <span class=\"token key atrule\">args</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token string\">'-c'</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n    tag=`cat tag.txt`\n    docker build -t \"gcr.io/gke-playground/$BRANCH_NAME:$tag\" .\n    docker push \"gcr.io/gke-playground/$BRANCH_NAME:$tag\"</span>\n    \n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> gcr.io/cloud<span class=\"token punctuation\">-</span>builders/kubectl\n  <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> deploy<span class=\"token punctuation\">-</span>infrastructure\n  <span class=\"token key atrule\">env</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'CLOUDSDK_COMPUTE_ZONE=australia-southeast1-a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'CLOUDSDK_CONTAINER_CLUSTER=features'</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key atrule\">entrypoint</span><span class=\"token punctuation\">:</span> bash\n  <span class=\"token key atrule\">args</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token string\">'-c'</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n    tag=`cat tag.txt`\n    sed -e \"s|_BRANCH_NAME|$BRANCH_NAME|g\" -e \"s|_TAG|$tag|g\" deployment-template.yaml | tee deployment.yaml\n    gcloud container clusters get-credentials --project=\"gke-playground\" --zone=\"australia-southeast1-a\" \"features\"\n    kubectl apply -f deployment.yaml</span></code></pre></div>\n<p>There are 3 build steps in our cloudbuild.yaml file. Each step has a name and and an id. The name field refers to a\ndocker image that the build step will pull and run to execute the step. Container builder supports a <a href=\"https://github.com/GoogleCloudPlatform/cloud-builders\" target=\"_blank\" rel=\"nofollow\">common set of builder\nimages</a> you can use as build steps. There are also <a href=\"https://github.com/GoogleCloudPlatform/cloud-builders-community\" target=\"_blank\" rel=\"nofollow\">community\nimages</a>. In this example we'll only\nuse google builder steps because it's more than sufficient for our needs.</p>\n<p>The id field is optional but useful to specify because it will be displayed in the build logs. Otherwise you'll see the\nname field instead, which is not as informative. Also by specifying an id,\nyou can make subsequent build steps to waitFor this build step so those child steps can run concurrently. Speed up baby! So cool!</p>\n<p>In the first step, we generate a random tag (based on an md5 hash of the current timestamp) for our docker image. Don't always tag\nyour images as latest because if the tag is unchanged, kubernetes won't be able to detect that the image has been updated\nand won't update your pods. We output the md5 hash to a text file in the checkout directory. The checkout directory\npersists across steps so we can access this text file later in subsequent steps.</p>\n<p>In the second step we build and push our docker image. We get the md5 hash from step 1 above and save it\nto a shell variable. We can then use this to build and push our docker image.</p>\n<p>Now we are ready to deploy our image! </p>\n<h2 id=\"step-4-deployment-templateyaml\"><a href=\"#step-4-deployment-templateyaml\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 4: deployment-template.yaml</h2>\n<p>Let's take a look at the third step which runs kubectl. This step deploys our docker image to the Kubernetes cluster. Note\nthat this step runs the <strong>gcr.io/cloud-builders/kubectl</strong> image, but we specified the\nentrypoint as bash meaning that the container will run the bash command when it starts rather\nthan kubectl. This is a useful technique if you need to pre-run some commands prior to executing\nthe main command. We'll come back to this in a minute after inspecting deployment-template.yaml:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Deployment\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> apps/v1beta1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> _BRANCH_NAME<span class=\"token punctuation\">-</span>deployment\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branchName</span><span class=\"token punctuation\">:</span> _BRANCH_NAME\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n  <span class=\"token key atrule\">selector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">matchLabels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">branchName</span><span class=\"token punctuation\">:</span> _BRANCH_NAME\n  <span class=\"token key atrule\">template</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">branchName</span><span class=\"token punctuation\">:</span> _BRANCH_NAME\n    <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> _BRANCH_NAME\n        <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> gcr.io/gke<span class=\"token punctuation\">-</span>playground/_BRANCH_NAME<span class=\"token punctuation\">:</span>_TAG\n        <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">containerPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span>\n\n<span class=\"token punctuation\">---</span>\n\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Service\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> _BRANCH_NAME<span class=\"token punctuation\">-</span>service\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branchName</span><span class=\"token punctuation\">:</span> _BRANCH_NAME\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">selector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branchName</span><span class=\"token punctuation\">:</span> _BRANCH_NAME\n  <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">protocol</span><span class=\"token punctuation\">:</span> TCP\n    <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span>\n    <span class=\"token key atrule\">targetPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span>\n  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> LoadBalancer</code></pre></div>\n<p>This is a standard kubernetes resource yaml specifying two resources to be created/updated in the cluster:</p>\n<ol>\n<li>\n<p>A deployment containing our pod spec</p>\n</li>\n<li>\n<p>A service to expose our pods to the external world so that it's accessible via the internet.</p>\n</li>\n</ol>\n<p>We use a placeholder string <em>BRANCH</em>NAME and <em>TAG which gets replaced by the real $BRANCH</em>NAME and our md5 hash using the sed command\nin our build step:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> -e <span class=\"token string\">\"s|_BRANCH_NAME|<span class=\"token variable\">$BRANCH_NAME</span>|g\"</span> -e <span class=\"token string\">\"s|_TAG|<span class=\"token variable\">$tag</span>|g\"</span> deployment-template.yaml <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> deployment.yaml</code></pre></div>\n<p>Like in the previous docker-build-push step, we get the tag from the md5 hash from step 1. $BRANCH_NAME is injected by\nthe Container Builder as an environment variable to all build steps. This is the git branch name that triggers the build.\nThere are <a href=\"https://cloud.google.com/container-builder/docs/configuring-builds/substitute-variable-values\" target=\"_blank\" rel=\"nofollow\">other environment variables</a>\nyou can use.</p>\n<p>This produces a new <code class=\"language-text\">deployment.yaml</code> which gets used by <code class=\"language-text\">kubectl</code> for deployment:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">kubectl apply -f deployment.yaml</code></pre></div>\n<p>This way, we can deploy each branch to its own infrastructure mirroring our git branching strategy.</p>\n<h2 id=\"step-5-test-the-app\"><a href=\"#step-5-test-the-app\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 5: Test the app!</h2>\n<p>Push a git commit to a feature branch and watch the magic happens! It takes a while for google cloud to assign an external\nip to our service. You can check under Compute -> Kubernetes Engine -> Discovery &#x26; load balancing. The <em>Endpoints</em> column\nshould display a valid external ip when it's ready. Then you can hit that link and your app should be running!</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>Deploying my app used to involve many moving parts: Jenkins, ec2 instances, load balancers, terraform, ecs. Kubernetes Engine\ngreatly simplifies this by encapsulating many of the moving parts. When used in conjunction with Container Builder, the\ndream of a continuous end to end build pipeline suddenly becomes somewhat easier to achieve. This is just the tip of the\niceberg, I am so excited! </p>\n<p>In part two of this series I'll walk you through the teardown process to complete the feature development pipeline.\nYou don't want unused resources running in the cloud burning your wallet! Till next time.</p>\n<hr>","timeToRead":7,"frontmatter":{"date":"February 28, 2018","path":"/docker-is-dead","title":"Docker is dead long live Kubernetes","files":[{"name":"create-cluster","publicURL":"/static/create-cluster-9306cce2e0bd30f103995b3bb9124bdd.png"},{"name":"create-trigger","publicURL":"/static/create-trigger-2c35c3d8e6b0765c67b495875dc6c5e4.png"}],"tags":["docker","kubernetes","engine","google","cloud","platform","ci","cd","continuous","deployment","integration","build","pipeline","end","to"]}}},"pageContext":{}}