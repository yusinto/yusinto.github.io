{"data":{"markdownRemark":{"html":"<p>An exciting new feature of js is async generator functions. A normal function in javascript is\nrun from beginning till end i.e. run to completion. Once invoked, the entire body\nof the function is executed until the end is reached. You can't stop or pause the execution of an\nordinary js function.</p>\n<p>Generator functions however, does not run to completion. You use the yield keyword to pause function\nexecution and then the next() method to continue execution.</p>\n<h2>Goal</h2>\n<p>Use async generator functions right now with babel.</p>\n<h2>Step 1: What is a generator function?</h2>\n<p>A generator function is a function which returns an iterator when run.\nAn iterator is an object that has a next() method implemented returning an object { value, done }.</p>\n<p>{% highlight javascript %}\nfunction* () {\nconsole.log(1);\nlet temp = yield \"first yield\";\nconsole.log(temp);\nyield \"second yield\";\nreturn;\n}\n{% endhighlight %}</p>\n<h2>Step 2: What is an async generator function?</h2>\n<p>Is the same as a generator function, BUT iterator.next() returns a promise returning the { value, done } object.</p>\n<p>{% highlight javascript %}\nasync function* () {\nconsole.log(1);\nlet temp = yield \"first yield\";\nconsole.log(temp);\nyield \"second yield\";\nreturn;\n}\n{% endhighlight %}</p>\n<h2>Step 3: How to use async generator with babel</h2>\n<p>{% highlight bash %}\nyarn add --dev babel-plugin-transform-async-to-generator babel-plugin-transform-async-generator-functions\n{% endhighlight %}</p>\n<p>Then in your .babelrc file:</p>\n<p>{% highlight json %}\n{\n\"plugins\": [\n\"transform-async-to-generator\",\n\"transform-async-generator-functions\"\n]\n}\n{% endhighlight %}</p>\n<p>Install relay-compiler-plus and the latest <a href=\"https://github.com/graphql/graphql-js\" target=\"_blank\" rel=\"nofollow\">graphql-js</a>{:target=\"_blank\"} package:</p>\n<p>{% highlight bash %}\nyarn add relay-compiler-plus\n{% endhighlight %}</p>\n<p>{% highlight bash %}\nyarn upgrade graphql --latest\n{% endhighlight %}</p>\n<h2>Step 2: Compile</h2>\n<p>Add this npm command to your <strong>package.json</strong>:</p>\n<p>{% highlight json %}\n\"scripts\": {\n\"rcp\": \"relay-compiler-plus --schema &#x3C;SCHEMA<em>FILE</em>PATH> --src &#x3C;SRC<em>DIR</em>PATH> -f\"\n},\n{% endhighlight %}\n<br>\nwhere:<br/>\n<code class=\"language-text\">&lt;SCHEMA_FILE_PATH&gt;</code> is the path to your schema.graphql or schema.json file<br/>\n<code class=\"language-text\">&lt;SRC_DIR_PATH&gt;</code> is the path to your src directory<br/>\n<code class=\"language-text\">-f</code> will delete all <code class=\"language-text\">**/__generated__/*.graphql.js</code> files under <code class=\"language-text\">SRC_DIR_PATH</code> before compilation starts<br/></p>\n<p>Run the command to start compiling:</p>\n<p>{% highlight bash %}\nnpm run rcp\n{% endhighlight %}</p>\n<h2>Step 3: Map query ids on the server</h2>\n<p>On the server, use <code class=\"language-text\">matchQueryMiddleware</code> prior to <code class=\"language-text\">express-graphql</code> to match query ids to actual queries. Note\nthat <code class=\"language-text\">queryMap.json</code> is auto-generated by <code class=\"language-text\">relay-compiler-plus</code> in the previous step.</p>\n<p>{% highlight javascript %}\nimport Express from 'express';\nimport expressGraphl from 'express-graphql';\nimport {matchQueryMiddleware} from 'relay-compiler-plus'; // do this\nimport queryMapJson from '../queryMap.json'; // do this</p>\n<p>const app = Express();</p>\n<p>app.use('/graphql',\nmatchQueryMiddleware(queryMapJson), // do this\nexpressGraphl({\nschema: graphqlSchema,\ngraphiql: true,\n}));\n{% endhighlight %}</p>\n<h2>Step 4: Send query ids on the client</h2>\n<p>On the client, modify your relay network fetch implementation to pass a <code class=\"language-text\">queryId</code> parameter in the\nrequest body instead of a <code class=\"language-text\">query</code> parameter. Note that <code class=\"language-text\">operation.id</code> is generated by <code class=\"language-text\">relay-compiler-plus</code> in step 2.</p>\n<p>{% highlight javascript %}\nfunction fetchQuery(operation, variables,) {\nreturn fetch('/graphql', {\nmethod: 'POST',\nheaders: {\n'content-type': 'application/json'\n},\nbody: JSON.stringify({\nqueryId: operation.id, // do this\nvariables,\n}),\n}).then(response => {\nreturn response.json();\n});\n}\n{% endhighlight %}</p>\n<h2>Bonus</h2>\n<p>In <a href=\"#step-2-compile\">step 2</a>, running relay-compiler-plus generates relay query files like the original relay-compiler,\nbut with a difference. Inspect a generated <code class=\"language-text\">ConcreteBatch</code> query file and you'll see that it now has an <code class=\"language-text\">id</code> assigned\nto it and that the query <code class=\"language-text\">text</code> is now <code class=\"language-text\">null</code>:</p>\n<p>{% highlight javascript %}\nconst batch /<em>: ConcreteBatch</em>/ = {\n\"fragment\": {\n\"argumentDefinitions\": [],\n\"kind\": \"Fragment\",\n\"metadata\": null,\n\"name\": \"client<em>index</em>Query\",\n\"selections\": [...],\n\"type\": \"Query\"\n},\n\"id\": \"6082095e8a45f64d38924775d047cf8c\", // look ma, query id!\n\"kind\": \"Batch\",\n\"metadata\": {},\n\"name\": \"client<em>index</em>Query\",\n\"query\": {...},\n\"text\": null // look again ma, null query text!\n};\n{% endhighlight %}</p>\n<p>The id is an md5 hash of the query text, generated by the <a href=\"https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js\" target=\"_blank\" rel=\"nofollow\">persistQuery</a>{:target=\"_blank\"}\nfunction. It looks like this:</p>\n<p>{% highlight javascript %}\nfunction persistQuery(operationText: string): Promise<string> {\nreturn new Promise((resolve) => {\nconst queryId = md5(operationText);\n<br>\n// queryCache is written to disk at the end as queryMap.json\nqueryCache.push({id: queryId, text: operationText});\nresolve(queryId);\n});\n}<br>\n{% endhighlight %}</p>\n<p>As you can see above, the hash to query text mapping is saved to an array which gets written to disk\nat the end of the compilation as queryMap.json. This is used on the server side as outlined in\n<a href=\"#step-3-map-query-ids-on-the-server\">step 3</a>.</p>\n<h2>Conclusion</h2>\n<p>You can find the package at <a href=\"https://github.com/yusinto/relay-compiler-plus\" target=\"_blank\" rel=\"nofollow\">github</a>{:target=\"<em>blank\"} with a fully working\n<a href=\"https://github.com/yusinto/relay-compiler-plus/tree/master/example\" target=\"_blank\" rel=\"nofollow\">example</a>{:target=\"</em>blank\"}. </p>\n<p>Let me know if this is useful (or not)! </p>\n<hr>","timeToRead":4,"frontmatter":{"date":"January 14, 2018","path":"/async-generator-functions","title":"Async Generator Functions","files":null,"tags":["async","generator","functions","iterator","yield","for-await-of","for","await","of"]}}},"pageContext":{}}