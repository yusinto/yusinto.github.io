{"componentChunkName":"component---src-pages-post-template-js","path":"/docker-ecs-terraform-react","result":{"data":{"site":{"siteMetadata":{"blurb":"Frontend Engineer @ LaunchDarkly. Book addict and tea lover. Passionate about react graphql and making things simple and fast."}},"markdownRemark":{"html":"<p>I was tinkering on blogging about Step 5 to React: Introduction to Redux, but I decided to write something closer to my heart:\nusing ecs and terraform to deploy docker react apps (can I squeeze in anymore buzzwords?). This is not an intro to docker so\nI assume you are familiar with the basics. </p>\n<p>My plan was to use docker to achieve continuous integration and ultimately continuous delivery and then deployment. But I like to\nstart things small so the plan was to firstly create a docker image on every master merge and save that image. </p>\n<p>This image\nis a stable and deployable package which can be deployed and run on any environment. This is the \"golden\" build concept - a single build\nthat is used on all steps of the deployment pipeline: uat, stage and prod. This is a good practice to adopt because the exact same\nbuild that has gone through all the QA steps is the one that's going out to production. </p>\n<p>It gives you confidence the prod deployment at the end\nwill work as expected. This is only possible if the package that comes out of your CI build is immutable - that's where docker comes in. I don't\nknow about you but I get really turned on by this kind of stuff! Let's get to it!</p>\n<h2 id=\"the-end-game\"><a href=\"#the-end-game\" aria-label=\"the end game permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The end game</h2>\n<p>By the end of this blog, we want to be able to create a docker image containing our react app, be able to run lint, tests and the actual app\non that image.</p>\n<p>We will be using the codebase from my <a href=\"/step-four-to-react-routing-with-react-router/\">previous blog on react router</a>. It's\na minimal react spa with routing, you should be able to easily substitute your own codebase and follow the steps here to use docker.</p>\n<h2 id=\"step-1-install-docker\"><a href=\"#step-1-install-docker\" aria-label=\"step 1 install docker permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 1: Install docker</h2>\n<p>I'm on a mac so download docker for mac from <a href=\"https://download.docker.com/mac/stable/Docker.dmg\" target=\"_blank\" rel=\"nofollow\">here</a>. It's a 110mb download so stop reading and do it first, continue reading later.\nThere are some hardware &#x26; os requirements. The important ones are:</p>\n<ul>\n<li>OS X 10.10.3 Yosemite or newer</li>\n<li>VirtualBox 4.3.30 or newer</li>\n</ul>\n<p>If you have a previous install of docker-machine, mac docker will ask if you want to migrate data from that install to your new install. I said no because I don't have anything\nimportant to migrate as I'll be starting from scratch.</p>\n<p>Once installation is done, open terminal and type:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">docker -v</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>You should get something like </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">Docker version <span class=\"token number\">1.12</span>.0, build 8eab29e</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Now we are ready to rock!</p>\n<h2 id=\"step-2-create-dockerfile\"><a href=\"#step-2-create-dockerfile\" aria-label=\"step 2 create dockerfile permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 2: Create Dockerfile</h2>\n<p>We need to create a Dockerfile first. This is the sequence of instructions you tell docker to execute to create the image.\nIt's akin to you manually entering a sequence of shell commands on the terminal of a new linux box when deploying your app. Except\ndocker runs it for you automatically, and then saves the resultant state of that linux box as an image.</p>\n<p>So right click on the root directory of your project, add a new file call it <i>Dockerfile</i>. It should look like this:</p>\n<h4 id=\"dockerfile\"><a href=\"#dockerfile\" aria-label=\"dockerfile permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DockerFile</h4>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-docker line-numbers\"><code class=\"language-docker\"><span class=\"token comment\"># We need a base image to build upon. Use the latest node image from </span>\n<span class=\"token comment\"># dockerhub as the base image so we get node and npm for free</span>\n<span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n<span class=\"token keyword\">MAINTAINER</span> Yus Ng\n\n<span class=\"token comment\"># Store all our app code in the /src folder, starting from package.json</span>\n<span class=\"token comment\"># first. Why copy package.json first? So we can take advantage of </span>\n<span class=\"token comment\"># the docker build cache. More below.</span>\n<span class=\"token keyword\">COPY</span> package.json /src/package.json\n\n<span class=\"token comment\"># Once we have package.json, do npm install (restricting the loglevel</span>\n<span class=\"token comment\"># to minimise noise)</span>\n<span class=\"token keyword\">RUN</span> cd /src &amp;&amp; npm install <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>loglevel error\n\n<span class=\"token comment\"># Copy all our code (yes including package.json again) to /src. </span>\n<span class=\"token keyword\">COPY</span> . /src\n\n<span class=\"token comment\"># Change directory into the /src folder so we can execute npm commands</span>\n<span class=\"token keyword\">WORKDIR</span> /src\n\n<span class=\"token comment\"># This is the express port on which our app runs</span>\n<span class=\"token keyword\">EXPOSE</span> 3000\n\n<span class=\"token comment\"># This is the default command to execute when docker run is issued. Only</span>\n<span class=\"token comment\"># one CMD instruction is allowed per Dockerfile.</span>\n<span class=\"token keyword\">CMD</span> npm start</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><b>Important points</b>: </p>\n<ul>\n<li>Each instruction creates a new intermediate layer.</li>\n<li>Docker uses the instruction string as the cache key. The result of that instruction is a new layer which gets stored as the cache value.</li>\n<li>ADD and COPY instructions are special. The cache key for these are the checksum of their file contents.</li>\n<li>If your package.json file does not change, the cache will be hit because the checksum matches. The next instruction npm install will also hit the cache \nbecause docker uses the instruction string as key which has not changed.</li>\n<li>In contrast, consider what will happen if do COPY . /src and then followed by RUN npm install.</li>\n<li>The COPY command does a checksum of all the files in current directory and compares that against previous layers. Some files\nwould have changed in the src folder, because it contains all our source code, images, config files, styles, etc. The checksum comparison would not match, hence\nthe cache will be invalidated. Once invalidated, all subsequent instructions will create new layers ignoring the cache.</li>\n</ul>\n<p>For more information on docker build cache check the official doco <a href=\"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/\" target=\"_blank\" rel=\"nofollow\">here</a>.</p>\n<h2 id=\"step-3-create-dockerignore\"><a href=\"#step-3-create-dockerignore\" aria-label=\"step 3 create dockerignore permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 3: Create .dockerignore</h2>\n<p>We need one more file before we can build our image. Go ahead and add a new file to the root directory of your project call it\n<i>.dockerignore</i></p>\n<p>Docker will exclude files and directories specified here from the image. It should look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">.git\n.gitignore\nnode_modules\nnpm-debug.log</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"step-4-build-the-docker-image\"><a href=\"#step-4-build-the-docker-image\" aria-label=\"step 4 build the docker image permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 4: Build the docker image</h2>\n<p>Let's do it! Go to terminal, cd into your root project folder where your Dockerfile resides and type the following (<b>NOTE</b> the \".\" at the end\nis very important!): </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">docker build -t reactjunkie:v1 <span class=\"token builtin class-name\">.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Docker will build an image named \"reactjunkie:v1\" using the Dockerfile specified in the current directory (represented by the \".\" at the end). You can see it\nby issuing the command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">docker images</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>You should see two images; the latest node base image which gets downloaded when docker built our image and our reactjunkie:v1 image.</p>\n<h2 id=\"step-5-run-the-docker-container\"><a href=\"#step-5-run-the-docker-container\" aria-label=\"step 5 run the docker container permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 5: Run the docker container</h2>\n<p>Now we have an image, we can start a container based on that image and run our app!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">docker run -d -p <span class=\"token number\">8080</span>:3000 reactjunkie:v1</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This command tells docker to run the default CMD command specified in the last line of our Dockerfile above. As we will see shortly we can\noverride this default by issuing our own commands.</p>\n<p>The -d flag tells docker to detach from the container process after issuing the command so we regain control of our terminal window.</p>\nThe -p flag maps the port on your mac (the host) to the container port.\nHit [http://localhost:8080](http://localhost:8080) and you should be able to see the app running!\n<h2 id=\"step-6-running-lint-and-test\"><a href=\"#step-6-running-lint-and-test\" aria-label=\"step 6 running lint and test permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 6: Running lint and test</h2>\n<p>So the previous step demonstrated how we can run our webapp on our docker container. However in a CI environment, we want to be able to first build our image,\nrun lint and tests and then save the image first prior to starting the web app. </p>\n<p>I've setup eslint and jest in this project (available on <a href=\"https://github.com/yusinto/docker\" target=\"_blank\" rel=\"nofollow\">github</a>). To run eslint and tests on our container, type\nthe following:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">docker run -i --rm reactjunkie:v1 <span class=\"token function\">npm</span> run lint\ndocker run -i --rm reactjunkie:v1 <span class=\"token function\">npm</span> t</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>The -i flag tells docker to run in \"interactive\" mode so we can see eslint console output from the container.</p>\n<p>The --rm flag tells docker to automatically clean up the container and remove its file system when the it exits.</p>\n<p>Then npm run lint and npm t are the commands that override the default CMD instruction in our Dockerfile. Docker will start\na container based on our image, issue these commands and then cleanup and remove the container when that command is finished.</p>\n<h2 id=\"whats-next\"><a href=\"#whats-next\" aria-label=\"whats next permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What's next?</h2>\n<p>Now we have the docker image on our local machine, we need a way to export it to a central place so it can be shared with other developers,\nbuild systems and so on. Docker has dockerhub which does exactly that, but I use ECR which is aws' offering.</p>\n<p>All the code in this blog are available on <a href=\"https://github.com/yusinto/docker\" target=\"_blank\" rel=\"nofollow\">github</a></p>\n<p>To be continued...</p>\n<hr>","timeToRead":6,"frontmatter":{"date":"September 03, 2016","path":"/docker-ecs-terraform-react","title":"Deploying react apps on docker using ecs and terraform part 1","files":null,"tags":["react","docker","ecs","terraform","deploy","continuous","integration","deployment"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}