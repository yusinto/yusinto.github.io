<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.0.3">Jekyll</generator>
<link href="http://reactjunkie.com/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://reactjunkie.com/" rel="alternate" type="text/html" />
<updated>2018-07-17T14:32:31+10:00</updated>
<id>http://reactjunkie.com/</id>
<title>React Junkie - Yusinto Ngadiman&#39;s Blog</title>
<entry>
<title>Introducing react-site-nav</title>
<link href="http://reactjunkie.com/react-site-nav/" rel="alternate" type="text/html" title="Introducing react-site-nav" />
<published>2018-07-13T07:30:00+10:00</published>
<updated>2018-07-13T07:30:00+10:00</updated>
<id>http://reactjunkie.com/react-site-nav</id>
<content type="html" xml:base="http://reactjunkie.com/react-site-nav/">&lt;p&gt;Stripe has a beautiful site nav and this package is inspired by that.
Introducing react-site-nav, a beautifully animated site nav powered by styled components
and css animations. Play with the &lt;a href=&quot;https://now-evztwufdfm.now.sh&quot; target=&quot;_blank&quot;&gt;live demo&lt;/a&gt; powered by now
or check out the video below.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Let’s use react-site-nav and add a kick ass nav to create-react-app!&lt;/p&gt;

&lt;h2 id=&quot;step-1-install&quot;&gt;Step 1: Install&lt;/h2&gt;

&lt;p&gt;We’ll create a new create-react-app project and install react-site-nav the usual way:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
create-react-app cra-with-nav
cd cra-with-nav
yarn add react-site-nav
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-adding-sitenav-and-contentgroup&quot;&gt;Step 2: Adding SiteNav and ContentGroup&lt;/h2&gt;

&lt;p&gt;Good stuff. Now we are going to add two components from react-site-nav to App.js: SiteNav and ContentGroup.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/c53edbc178d9dd3289c1a80050e9f20f.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;SiteNav is the root react component that contains ContentGroup children.
Each ContentGroup can accept 3 props: title, width and height.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/react-site-nav-content-group.png&quot; width=&quot;400&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;step-3-making-it-pretty&quot;&gt;Step 3: Making it pretty&lt;/h2&gt;

&lt;p&gt;It takes only a few lines of code to get up and going, but it still looks very basic.
Let’s make it pretty! First, set our SiteNav to debug mode so the content group stays open
when we hover over it:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
&amp;lt;SiteNav debug={true}&amp;gt;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Let’s get rid of those ugly default list style, margin and padding:&lt;/p&gt;

&lt;p&gt;{% highlight css %}
ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Next instead of a bullet point, let’s have an image next to our text. Our jsx becomes:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/840ecdba5ce0d8f4bf85fa11ae2a4e51.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Let’s use flex for our list item so we can easily center everything:&lt;/p&gt;

&lt;p&gt;{% highlight css %}
li {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 60px;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;It’s starting to look good! Just some finishing touches now to make the images and text vertically
aligned and some hover effects:&lt;/p&gt;

&lt;p&gt;{% highlight css %}
li:hover {
    opacity: 0.7;
}&lt;/p&gt;

&lt;p&gt;li &amp;gt; span {
    flex: 0 0 100px;
    text-align: left;
    margin-left: 10px;
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;tadaa&quot;&gt;Tadaa&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/before-after.png&quot; alt=&quot;Before and after&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Check out the live demo &lt;a href=&quot;https://build-licattzisr.now.sh/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;. The complete stylesheet:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/9a04ad983ff2b03a140683d45ef9405b.js&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;
&lt;p&gt;There are still loads left to do, like mobile and sizing near edges. I’ll get to those in time!&lt;/p&gt;

&lt;p&gt;For more, check out &lt;a href=&quot;https://github.com/yusinto/react-site-nav&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;. There are three fully
working spas including the code in this blog in the &lt;a href=&quot;https://github.com/yusinto/react-site-nav/tree/master/examples&quot; target=&quot;_blank&quot;&gt;examples&lt;/a&gt;
folder. The code in this blog is under &lt;a href=&quot;https://github.com/yusinto/react-site-nav/tree/master/examples/cra-with-nav&quot; target=&quot;_blank&quot;&gt;examples/cra-with-nav&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please star it if you like it! Thanks.&lt;/p&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mxstbr.com/&quot; target=&quot;_blank&quot;&gt;Max Stoiber&lt;/a&gt; is awesome.
&lt;a href=&quot;https://www.styled-components.com/&quot; target=&quot;_blank&quot;&gt;Styled components&lt;/a&gt; is awesome.
&lt;a href=&quot;https://zeit.co/now&quot; target=&quot;_blank&quot;&gt;Now&lt;/a&gt; is awesome. Thanks.&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="react" />
<category term="site" />
<category term="nav" />
<category term="navigation" />
<category term="bar" />
<category term="navbar" />
<category term="stripe" />
<category term="styled" />
<category term="components" />
<category term="menu" />
<category term="css" />
<category term="animations" />
<category term="grid" />
<category term="cssgrid" />
<summary>Stripe has a beautiful site nav and this package is inspired by that.Introducing react-site-nav, a beautifully animated site nav powered by styled componentsand css animations. Play with the live demo powered by nowor check out the video below.</summary>
</entry>
<entry>
<title>React integration with Launch Darkly using ld-react</title>
<link href="http://reactjunkie.com/ld-react-context-api/" rel="alternate" type="text/html" title="React integration with Launch Darkly using ld-react" />
<published>2018-05-30T07:30:00+10:00</published>
<updated>2018-05-30T07:30:00+10:00</updated>
<id>http://reactjunkie.com/ld-react-context-api</id>
<content type="html" xml:base="http://reactjunkie.com/ld-react-context-api/">&lt;p&gt;About two years ago I wrote a package &lt;a href=&quot;https://github.com/yusinto/ld-redux&quot; target=&quot;_blank&quot;&gt;ld-redux&lt;/a&gt;
which allows easy integration of Launch Darkly and react redux apps. That package is still alive and well, but with
the introduction of the context api in react 16.3 we can do better.&lt;/p&gt;

&lt;p&gt;Introducing &lt;a href=&quot;https://github.com/yusinto/ld-react&quot; target=&quot;_blank&quot;&gt;ld-react&lt;/a&gt;, the fastest and easiest way to
integrate launch darkly with your react apps. Live subscription works out of the box and you get camelCased keys for a better
developer experience. Integration is a two step process and best of all no redux!&lt;/p&gt;

&lt;h2 id=&quot;step-1-install&quot;&gt;Step 1: Install&lt;/h2&gt;

&lt;p&gt;You need react ^16.4 to use ld-react.&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add ld-react
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-wrap-your-root-app-withflagprovider&quot;&gt;Step 2: Wrap your root app withFlagProvider&lt;/h2&gt;

&lt;p&gt;The withFlagProvider hoc initialises an ldClient object on componentDidMount and sets up subscriptions to all flags.
It then uses the context api to pass flag values to consumers.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/a31074588c26c2ce747505bcbd49400b.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;You can also pass a user object and options as part of the second parameter in addition to clientSideId. However, they are
not mandatory.&lt;/p&gt;

&lt;h2 id=&quot;step-3-where-you-need-flags-wrap-that-component-withflags&quot;&gt;Step 3: Where you need flags, wrap that component withFlags&lt;/h2&gt;

&lt;p&gt;The withFlags hoc sets up a context consumer which passes flags to the wrapped component. Your flags will then be
available as camelCased keys under &lt;code class=&quot;highlighter-rouge&quot;&gt;this.props.flags.yourFeatureFlag&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/195df27bbba1044c3773a9c4a86db057.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;That’s it! For more, check out &lt;a href=&quot;https://github.com/yusinto/ld-react&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;. There is also a fully
working spa &lt;a href=&quot;https://github.com/yusinto/ld-react/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt; with react router 4 and
ssr.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="ld-react" />
<category term="launch" />
<category term="darkly" />
<category term="react" />
<category term="feature" />
<category term="flag" />
<category term="integration" />
<category term="context" />
<category term="api" />
<category term="toggle" />
<summary>About two years ago I wrote a package ld-reduxwhich allows easy integration of Launch Darkly and react redux apps. That package is still alive and well, but withthe introduction of the context api in react 16.3 we can do better.</summary>
</entry>
<entry>
<title>Relay Schema Stitching with Pesisted Queries</title>
<link href="http://reactjunkie.com/relay-schema-stitching/" rel="alternate" type="text/html" title="Relay Schema Stitching with Pesisted Queries" />
<published>2018-04-27T07:30:00+10:00</published>
<updated>2018-04-27T07:30:00+10:00</updated>
<id>http://reactjunkie.com/relay-schema-stitching</id>
<content type="html" xml:base="http://reactjunkie.com/relay-schema-stitching/">&lt;p&gt;Schema stitching was introduced by Apollo, so there is a general misconception that it
only works with the apollo stack but it works with relay as well! In this blog
I’ll show you how to stitch your relay schema with any remote graphql schema.&lt;/p&gt;

&lt;p&gt;You can find the complete project in &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example-stitching&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Given a local schema that looks like this:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/c4c6a8f376a36f600ddb0f1f24c952df.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Stitch it so that business details are coming from a remote graphql server, in this case from &lt;a href=&quot;https://eu1.prisma.sh/public-nickelwarrior-830/wendarie-prisma/dev&quot; target=&quot;_blank&quot;&gt;prisma&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;step-1-install-graphql-cli&quot;&gt;Step 1: Install graphql-cli&lt;/h2&gt;
&lt;p&gt;We’ll use graphql cli to download the remote schema:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add -D graphql-cli
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-download-the-remote-schema&quot;&gt;Step 2: Download the remote schema&lt;/h2&gt;
&lt;p&gt;Graphql cli looks for a .graphqlconfig.yml by default, so we’ll create that file
and it looks like this:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/7cfbeeac5e0b6a35dde44a72e5e1a268.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;In this example, our business details are hosted in &lt;a href=&quot;https://eu1.prisma.sh/public-nickelwarrior-830/wendarie-prisma/dev&quot; target=&quot;_blank&quot;&gt;prisma&lt;/a&gt; 
but you can use any graphql endpoint. &lt;a href=&quot;https://prisma.io&quot; target=&quot;_blank&quot;&gt;Prisma&lt;/a&gt; is created by the guys from 
graphcool, check it out if you haven’t!&lt;/p&gt;

&lt;p&gt;Run the following to download the remote schema to ./remote.schema.graphql:
{% highlight bash %}
graphql get-schema
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-stitch&quot;&gt;Step 3: Stitch&lt;/h2&gt;
&lt;p&gt;The stitching part is standard, following &lt;a href=&quot;https://www.apollographql.com/docs/graphql-tools/schema-stitching.html&quot; target=&quot;_blank&quot;&gt;Apollo’s doco&lt;/a&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/9ab425fc0a100f81c183e824f1405b57.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Important bits&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Line 11: Import the remote schema we downloaded from step 2 using graphql-import. This gets
fed into makeRemoteExecutableSchema.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Line 14: Use apollo-link to resolve remote queries! If you look at the documentation, there is
a second option of using a fetcher. However doing this will forward the Document AST
to the remote server instead of the query string, which breaks most graphql servers except 
apollo-server.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Line 20: Extend the Place type to include a reference to Business, which will be resolved to
the remote server via mergeSchemas in line 29.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Line 29: This defines the resolver for the business field. The key here is the &lt;code class=&quot;highlighter-rouge&quot;&gt;delegateToSchema&lt;/code&gt;
method which gives you access to the current &lt;code class=&quot;highlighter-rouge&quot;&gt;Place&lt;/code&gt; being queried based on the fragment defined
in line 30, and access to the remote schema so you can query the remote server with any queries 
you want. In this instance, the query we want to execute on prisma is equivalent to:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/650e2f21fc82d8e5e07577a9683e0e76.js&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;step-4-compile&quot;&gt;Step 4: Compile&lt;/h2&gt;
&lt;p&gt;Say we have a relay query like so:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/44be0c2447ceb723197e3a9bbf2894c9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;We’ll compile our relay queries using &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;relay-compiler-plus&lt;/a&gt;.
This way we’ll get schema stitching plus persisted queries for free! You can still use the standard relay-compiler,
but you won’t get persisted queries (not yet anyway. I have submitted a &lt;a href=&quot;https://github.com/facebook/relay/pull/2354&quot; target=&quot;_blank&quot;&gt;pr&lt;/a&gt;) 
and you can’t compile directly from graphql-js.&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add -D relay-compiler-plus
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Add the following npm command to your package.json:
{% highlight bash %}
“rcp”: “relay-compiler-plus –webpackConfig path/to/webpack.config.js –src src”,
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Ensure the webpack entry is pointing to mergedSchema.js from step 3. Then run:
{% highlight bash %}
npm run rcp
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This should produce the standard relay query files plus a queryMap.json file under src. You’ll see in queryMap.json that 
the remote query exists as if it’s local!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It is possible to use relay and schema stitching. It is surprisingly straight forward thanks to the tools provided
by Apollo. It is impossible to document every single step in this blog without boring everyone to death. People don’t read
blogs more than 4 mins long these days… so perhaps it’s best to see it in action.&lt;/p&gt;

&lt;p&gt;Check out the full project on &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example-stitching&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy stitching!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/loui-stitch.jpg&quot; alt=&quot;Loui stitch?&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="relay" />
<category term="schema" />
<category term="stitching" />
<category term="graphql" />
<category term="apollo" />
<category term="react" />
<category term="js" />
<category term="javascript" />
<category term="prisma" />
<category term="graphcool" />
<category term="persisted" />
<category term="queries" />
<summary>Schema stitching was introduced by Apollo, so there is a general misconception that itonly works with the apollo stack but it works with relay as well! In this blogI’ll show you how to stitch your relay schema with any remote graphql schema.</summary>
</entry>
<entry>
<title>Javascript Lessons: toJSON and valueOf</title>
<link href="http://reactjunkie.com/js-lessons-tojson-valueof/" rel="alternate" type="text/html" title="Javascript Lessons: toJSON and valueOf " />
<published>2018-03-28T07:30:00+11:00</published>
<updated>2018-03-28T07:30:00+11:00</updated>
<id>http://reactjunkie.com/js-lessons-tojson-valueof</id>
<content type="html" xml:base="http://reactjunkie.com/js-lessons-tojson-valueof/">&lt;h2 id=&quot;tojson&quot;&gt;toJSON()&lt;/h2&gt;
&lt;p&gt;If you need a custom output when json stringifying your object, you can define
a function called toJSON() which will be invoked automatically by
JSON.stringify():&lt;/p&gt;

&lt;p data-height=&quot;376&quot; data-theme-id=&quot;dark&quot; data-slug-hash=&quot;KoZmLa&quot; data-default-tab=&quot;js,result&quot; data-user=&quot;yusinto&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;Javascript Lessons&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/yusinto/pen/KoZmLa/&quot;&gt;Javascript Lessons&lt;/a&gt; by Yusinto Ngadiman (&lt;a href=&quot;https://codepen.io/yusinto&quot;&gt;&lt;a href=&quot;https://github.com/yusinto&quot; class=&quot;user-mention&quot;&gt;@yusinto&lt;/a&gt;&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;script async=&quot;&quot; src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Without the custom toJSON() implementation, the code above will use the default
implementation:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
{“firstName”:”Yus”,”lastName”:”Ng”}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;valueof&quot;&gt;valueOf()&lt;/h2&gt;
&lt;p&gt;Object.prototype has a built-in valueOf method which returns the primitive value
of the object. You can override this method to return a custom primitive value
for your object:&lt;/p&gt;

&lt;p data-height=&quot;372&quot; data-theme-id=&quot;dark&quot; data-slug-hash=&quot;YaYQyo&quot; data-default-tab=&quot;js,result&quot; data-user=&quot;yusinto&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;Javascript Lessons: valueOf&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/yusinto/pen/YaYQyo/&quot;&gt;Javascript Lessons: valueOf&lt;/a&gt; by Yusinto Ngadiman (&lt;a href=&quot;https://codepen.io/yusinto&quot;&gt;&lt;a href=&quot;https://github.com/yusinto&quot; class=&quot;user-mention&quot;&gt;@yusinto&lt;/a&gt;&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;script async=&quot;&quot; src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;The override allows us to perform arithmetic with our object. Without the override,
the valueOf myCar will be NaN (Not-a-Number).&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="javascript" />
<category term="tojson" />
<category term="valueof" />
<category term="json" />
<category term="stringify" />
<category term="lessons" />
<summary>toJSON()If you need a custom output when json stringifying your object, you can definea function called toJSON() which will be invoked automatically byJSON.stringify():</summary>
</entry>
<entry>
<title>Docker is dead long live Kubernetes</title>
<link href="http://reactjunkie.com/docker-is-dead/" rel="alternate" type="text/html" title="Docker is dead long live Kubernetes" />
<published>2018-02-28T07:30:00+11:00</published>
<updated>2018-02-28T07:30:00+11:00</updated>
<id>http://reactjunkie.com/docker-is-dead</id>
<content type="html" xml:base="http://reactjunkie.com/docker-is-dead/">&lt;p&gt;&lt;strong&gt;Update 22 Mar 2018&lt;/strong&gt;: Fixed cloudbuild.yaml to generate a docker tag every time otherwise kubernetes does not detect changes.&lt;/p&gt;

&lt;p&gt;Kubernetes rocks. Kubernetes engine to be exact. I was so inspired by Kelsey Hightower’s
&lt;a href=&quot;https://www.youtube.com/watch?v=kOa_llowQ1c&amp;amp;feature=youtu.be&quot; target=&quot;_blank&quot;&gt;presentation&lt;/a&gt; at KubeCon 2017 I
spent the next 2 weeks migrating my entire pipeline from Jenkins/AWS/Terraform to Google Cloud Platform (GCP for short) 
and the Kubernetes Engine. It’s the best decision I have ever made.&lt;/p&gt;

&lt;p&gt;Ok so the title is a little dramatic. Kubernetes uses docker so it doesn’t actually really kill docker, it merely pushes
it further into the background. That means you are free to focus on the bigger picture, which is your end to end pipeline
and your code. During my migration, I found that apart from the dockerfile and a docker build, I didn’t really have to
touch docker much. It’s a sign that the docker stack has matured.&lt;/p&gt;

&lt;p&gt;In this blog I’ll walk you through how to set up a continuous dev pipeline on GCP and the Kubernetes Engine.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;During development, the dev test cycle is predictable and well-defined. You write code, it runs locally and pass all the 
tests then you push your code to git. The &lt;em&gt;intent&lt;/em&gt; is clear. Pushing to git means you want to see that code running on an 
environment somewhere. This environment should also be predictable and well-defined. Without doing any more work, you
should be able to open your browser and run the code you just pushed in this well-defined environment.&lt;/p&gt;

&lt;p&gt;The goal of this tutorial is to build a pipeline that does exactly that. At the end of this post, you should be able to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Create a new feature off master, code and test locally.&lt;/li&gt;
  &lt;li&gt;Push to git.&lt;/li&gt;
  &lt;li&gt;Browse to a well-defined feature url which has the new code running.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;step-1-create-a-kubernetes-cluster&quot;&gt;Step 1: Create a Kubernetes cluster&lt;/h2&gt;
&lt;p&gt;Jump into google cloud console and under the main menu, go to Compute -&amp;gt; Kubernetes Engine -&amp;gt; Kubernetes clusters and
click on Create Cluster. You’ll see a screen like below, you only need to touch 3 fields:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/create-cluster.png&quot; alt=&quot;Create Kubernetes cluster&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Name your cluster &lt;em&gt;feature-cluster&lt;/em&gt;. When we push to git, we’ll deploy our feature to nodes running on this cluster.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pick a zone that’s closest to you. The Zonal and Regional option refers to the location of your Kubernetes master. 
Zonal means your master service will be running in a single zone that you picked. Regional means your master service 
will be running in multiple zones in that region for redundancy. To keep things simple for this demo we’ll stick with zonal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pick the latest cluster version to get all the latest features.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Leave the remaining default settings e.g. 3 nodes in the cluster on Container-Optimised OS and click create. It takes 
some time for google to create your cluster because it has to provision the nodes. While that’s cooking, we’ll create 
the build job.&lt;/p&gt;

&lt;h2 id=&quot;step-2-create-a-build-trigger&quot;&gt;Step 2: Create a build trigger&lt;/h2&gt;
&lt;p&gt;In the console menu, go to Tools -&amp;gt; Container Registry -&amp;gt; Build triggers. Add a new trigger. Select your git source
(I use github) and repo and authorise container builder to access it. Then you’ll get to the
Edit Trigger page like below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/create-trigger.png&quot; alt=&quot;Container builder trigger settings&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Give your trigger a name, I name mine &lt;em&gt;feature&lt;/em&gt; because it gets triggered by a feature push and builds and deploys 
that feature.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set the trigger type to branch, because we want to trigger a build when a feature branch push happens. There is also
an option to trigger on tag push, which is useful for production deployment (when you create a release tag) but we’ll
cover that in a future post.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set a regex to match the feature branch names. By convention I enforce the following convention for features:
feature-[JIRA_TICKET_NUMBER]-description. All the developers follow this naming convention when they create a new
feature branch. Once a convention is in place, you can set a regex expression here to match your feature branches.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You define your build steps in the cloudbuild.yaml file. Set the location of &lt;em&gt;cloudbuild.yaml&lt;/em&gt; so container builder
can find it in your repo. I set mine to the root of my repo.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;step-3-cloudbuildyaml&quot;&gt;Step 3: cloudbuild.yaml&lt;/h2&gt;
&lt;p&gt;Container builder uses this file to execute a series of steps to build and deploy your app. Each build step specified
here is a container running in its own shell. For our demo, we’ll use the cloudbuild.yaml below:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/3922f40d0b8d0241b6c6ead1a9aa8f3f.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;There are 3 build steps in our cloudbuild.yaml file. Each step has a name and and an id. The name field refers to a
docker image that the build step will pull and run to execute the step. Container builder supports a &lt;a href=&quot;https://github.com/GoogleCloudPlatform/cloud-builders&quot; target=&quot;_blank&quot;&gt;common set of builder
images&lt;/a&gt; you can use as build steps. There are also &lt;a href=&quot;https://github.com/GoogleCloudPlatform/cloud-builders-community&quot; target=&quot;_blank&quot;&gt;community
images&lt;/a&gt;. In this example we’ll only
use google builder steps because it’s more than sufficient for our needs.&lt;/p&gt;

&lt;p&gt;The id field is optional but useful to specify because it will be displayed in the build logs. Otherwise you’ll see the
name field instead, which is not as informative. Also by specifying an id,
you can make subsequent build steps to waitFor this build step so those child steps can run concurrently. Speed up baby! So cool!&lt;/p&gt;

&lt;p&gt;In the first step, we generate a random tag (based on an md5 hash of the current timestamp) for our docker image. Don’t always tag
your images as latest because if the tag is unchanged, kubernetes won’t be able to detect that the image has been updated
and won’t update your pods. We output the md5 hash to a text file in the checkout directory. The checkout directory
persists across steps so we can access this text file later in subsequent steps.&lt;/p&gt;

&lt;p&gt;In the second step we build and push our docker image. We get the md5 hash from step 1 above and save it
to a shell variable. We can then use this to build and push our docker image.&lt;/p&gt;

&lt;p&gt;Now we are ready to deploy our image!&lt;/p&gt;

&lt;h2 id=&quot;step-4-deployment-templateyaml&quot;&gt;Step 4: deployment-template.yaml&lt;/h2&gt;
&lt;p&gt;Let’s take a look at the third step which runs kubectl. This step deploys our docker image to the Kubernetes cluster. Note
that this step runs the &lt;strong&gt;gcr.io/cloud-builders/kubectl&lt;/strong&gt; image, but we specified the
entrypoint as bash meaning that the container will run the bash command when it starts rather
than kubectl. This is a useful technique if you need to pre-run some commands prior to executing
the main command. We’ll come back to this in a minute after inspecting deployment-template.yaml:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/9536fa7dcd28106efee7f8b217a9d06a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;This is a standard kubernetes resource yaml specifying two resources to be created/updated in the cluster:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A deployment containing our pod spec&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A service to expose our pods to the external world so that it’s accessible via the internet.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We use a placeholder string _BRANCH_NAME and _TAG which gets replaced by the real $BRANCH_NAME and our md5 hash using the sed command
in our build step:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
sed -e “s|_BRANCH_NAME|$BRANCH_NAME|g” -e “s|_TAG|$tag|g” deployment-template.yaml | tee deployment.yaml
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Like in the previous docker-build-push step, we get the tag from the md5 hash from step 1. $BRANCH_NAME is injected by 
the Container Builder as an environment variable to all build steps. This is the git branch name that triggers the build. 
There are &lt;a href=&quot;https://cloud.google.com/container-builder/docs/configuring-builds/substitute-variable-values&quot; target=&quot;_blank&quot;&gt;other environment variables&lt;/a&gt; 
you can use.&lt;/p&gt;

&lt;p&gt;This produces a new &lt;code class=&quot;highlighter-rouge&quot;&gt;deployment.yaml&lt;/code&gt; which gets used by &lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; for deployment:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
kubectl apply -f deployment.yaml
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This way, we can deploy each branch to its own infrastructure mirroring our git branching strategy.&lt;/p&gt;

&lt;h2 id=&quot;step-5-test-the-app&quot;&gt;Step 5: Test the app!&lt;/h2&gt;
&lt;p&gt;Push a git commit to a feature branch and watch the magic happens! It takes a while for google cloud to assign an external 
ip to our service. You can check under Compute -&amp;gt; Kubernetes Engine -&amp;gt; Discovery &amp;amp; load balancing. The &lt;em&gt;Endpoints&lt;/em&gt; column 
should display a valid external ip when it’s ready. Then you can hit that link and your app should be running!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Deploying my app used to involve many moving parts: Jenkins, ec2 instances, load balancers, terraform, ecs. Kubernetes Engine
greatly simplifies this by encapsulating many of the moving parts. When used in conjunction with Container Builder, the 
dream of a continuous end to end build pipeline suddenly becomes somewhat easier to achieve. This is just the tip of the
iceberg, I am so excited!&lt;/p&gt;

&lt;p&gt;In part two of this series I’ll walk you through the teardown process to complete the feature development pipeline. 
You don’t want unused resources running in the cloud burning your wallet! Till next time.&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="docker" />
<category term="kubernetes" />
<category term="engine" />
<category term="google" />
<category term="cloud" />
<category term="platform" />
<category term="ci" />
<category term="cd" />
<category term="continuous" />
<category term="deployment" />
<category term="integration" />
<category term="build" />
<category term="pipeline" />
<category term="end" />
<category term="to" />
<category term="end" />
<summary>Update 22 Mar 2018: Fixed cloudbuild.yaml to generate a docker tag every time otherwise kubernetes does not detect changes.</summary>
</entry>
<entry>
<title>Launch Darkly, React and Redux: The Easy Way</title>
<link href="http://reactjunkie.com/ld-redux-v3/" rel="alternate" type="text/html" title="Launch Darkly, React and Redux: The Easy Way" />
<published>2018-01-14T07:30:00+11:00</published>
<updated>2018-01-14T07:30:00+11:00</updated>
<id>http://reactjunkie.com/ld-redux-v3</id>
<content type="html" xml:base="http://reactjunkie.com/ld-redux-v3/">&lt;p&gt;About a year and a bit ago I published ld-redux to integrate launch darkly with react and redux. I used that solution
both commercially in production and personally. It has been stable thus far. There were issues though:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ld-redux state contains a somewhat mysterious internal property called &lt;em&gt;isLDReady&lt;/em&gt; which is a pain in the butt.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;components have to be connected via a hoc called &lt;em&gt;ldConnect&lt;/em&gt; which is again a pain.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The subscription logic for flag changes in that hoc might result in duplicate subscriptions which is inefficient.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these in mind, I introduce to you (drum roll) &lt;a href=&quot;https://github.com/yusinto/ld-redux&quot; target=&quot;_blank&quot;&gt;ld-redux v3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;whats-new&quot;&gt;What’s new?&lt;/h2&gt;
&lt;p&gt;There’s no longer need to worry about &lt;em&gt;isLDReady&lt;/em&gt;. It has been deleted completely from the package.&lt;/p&gt;

&lt;p&gt;There’s no longer need to connect using &lt;em&gt;ldConnect&lt;/em&gt; either! It is gone baby gone!&lt;/p&gt;

&lt;p&gt;You can consume your flags directly from your redux store without having to use &lt;em&gt;getFlags()&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The subscription logic has been moved to the &lt;em&gt;init()&lt;/em&gt; method so all subscriptions are done just once. Very efficient.&lt;/p&gt;

&lt;h1 style=&quot;color: red&quot;&gt;!!WARNING!!&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/steve-jobs-small.jpg&quot; alt=&quot;Backwards compatibility?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;v3 is &lt;strong&gt;NOT&lt;/strong&gt; backwards compatible with v1.x! So be prepared to do some refactoring if you are on v1 upgrading to v3.
It’s a simple upgrade though. You will be deleting code most of the time. ld-redux v3 is launch darkly 
and redux as it’s meant to be!&lt;/p&gt;

&lt;h2 id=&quot;how-to-use&quot;&gt;How to use?&lt;/h2&gt;
&lt;p&gt;You include ldReducer in your app and call the init method once at bootstrap. Your flags will then be available
in your redux state as camel cased keys. That’s it!&lt;/p&gt;

&lt;h4 id=&quot;clientbootstrapjs&quot;&gt;clientBootstrap.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
import createStore from ‘&lt;your-project&gt;/store&#39;;
import ldRedux from &#39;ld-redux&#39;;&lt;/your-project&gt;&lt;/p&gt;

&lt;p&gt;// standard redux createStore
const store = createStore();&lt;/p&gt;

&lt;p&gt;// Tip: you can declare your flags inline or import it as a json file
const flags = { ‘feature-flag-key’: false };&lt;/p&gt;

&lt;p&gt;// Init once on bootstrap to set default flag values and subscriptions
ldRedux.init({
  clientSideId: ‘your-client-side-id’,
  store,
  flags,
});&lt;/p&gt;

&lt;p&gt;render(
  &amp;lt;Provider store={store}&amp;gt;
    &amp;lt;Router routes={routes} history={browserHistory}/&amp;gt;
  &amp;lt;/Provider&amp;gt;,
  document.getElementById(‘reactDiv’)
);
{% endhighlight %}&lt;/p&gt;

&lt;h4 id=&quot;reducerjs&quot;&gt;reducer.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
import { combineReducers } from ‘redux’;
import ldRedux from ‘ld-redux’;
import reducers from ‘&lt;your-project&gt;/reducers&#39;;&lt;/your-project&gt;&lt;/p&gt;

&lt;p&gt;// Note: the LD key can be anything you want
export default combineReducers({
  …reducers,
  LD: ldRedux.reducer(),
});
{% endhighlight %}&lt;/p&gt;

&lt;h4 id=&quot;yourcomponentjs&quot;&gt;yourComponent.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
…&lt;/p&gt;

&lt;p&gt;const mapStateToProps = (state) =&amp;gt; {
  // Your camelCased feature flags are magically available in the store!
  // Note: the key LD must be the same as step 2
  const {featureFlagKey} = state.LD;&lt;/p&gt;

&lt;p&gt;return {
    featureFlagKey,
  };
};&lt;/p&gt;

&lt;p&gt;…
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Check the fully working &lt;a href=&quot;https://github.com/yusinto/ld-redux/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt; on github.&lt;/p&gt;

&lt;p&gt;Oh and one more thing in case someone asks what happened to ld-redux v2? It went from v1.4.x to v3.0.1. What the heck?
Umm I made a mistake during publishing (entered npm version update major twice) so it became v3. Doesn’t matter! As long
as it works right?&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="launch" />
<category term="darkly" />
<category term="react" />
<category term="redux" />
<category term="feature" />
<category term="flags" />
<category term="toggle" />
<summary>About a year and a bit ago I published ld-redux to integrate launch darkly with react and redux. I used that solutionboth commercially in production and personally. It has been stable thus far. There were issues though:</summary>
</entry>
<entry>
<title>Async Generator Functions</title>
<link href="http://reactjunkie.com/async-generator-functions/" rel="alternate" type="text/html" title="Async Generator Functions" />
<published>2018-01-14T07:30:00+11:00</published>
<updated>2018-01-14T07:30:00+11:00</updated>
<id>http://reactjunkie.com/async-generator-functions</id>
<content type="html" xml:base="http://reactjunkie.com/async-generator-functions/">&lt;p&gt;An exciting new feature of js is async generator functions. A normal function in javascript is
run from beginning till end i.e. run to completion. Once invoked, the entire body
of the function is executed until the end is reached. You can’t stop or pause the execution of an
ordinary js function.&lt;/p&gt;

&lt;p&gt;Generator functions however, does not run to completion. You use the yield keyword to pause function
execution and then the next() method to continue execution.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Use async generator functions right now with babel.&lt;/p&gt;

&lt;h2 id=&quot;step-1-what-is-a-generator-function&quot;&gt;Step 1: What is a generator function?&lt;/h2&gt;
&lt;p&gt;A generator function is a function which returns an iterator when run.
An iterator is an object that has a next() method implemented returning an object { value, done }.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function* () {
    console.log(1);
    let temp = yield “first yield”;
    console.log(temp);
    yield “second yield”;
    return;
} 
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-what-is-an-async-generator-function&quot;&gt;Step 2: What is an async generator function?&lt;/h2&gt;
&lt;p&gt;Is the same as a generator function, BUT iterator.next() returns a promise returning the { value, done } object.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
async function* () {
    console.log(1);
    let temp = yield “first yield”;
    console.log(temp);
    yield “second yield”;
    return;
} 
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-how-to-use-async-generator-with-babel&quot;&gt;Step 3: How to use async generator with babel&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
yarn add –dev babel-plugin-transform-async-to-generator babel-plugin-transform-async-generator-functions
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Then in your .babelrc file:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
{
  “plugins”: [
    “transform-async-to-generator”,
    “transform-async-generator-functions”
  ]
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Install relay-compiler-plus and the latest &lt;a href=&quot;https://github.com/graphql/graphql-js&quot; target=&quot;_blank&quot;&gt;graphql-js&lt;/a&gt; package:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add relay-compiler-plus
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn upgrade graphql –latest
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-compile&quot;&gt;Step 2: Compile&lt;/h2&gt;
&lt;p&gt;Add this npm command to your &lt;strong&gt;package.json&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
“scripts”: {
    “rcp”: “relay-compiler-plus –schema &lt;schema_file_path&gt; --src &lt;src_dir_path&gt; -f&quot;
},
{% endhighlight %}&lt;/src_dir_path&gt;&lt;/schema_file_path&gt;&lt;/p&gt;

&lt;p&gt;where:&lt;br /&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SCHEMA_FILE_PATH&amp;gt;&lt;/code&gt; is the path to your schema.graphql or schema.json file&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SRC_DIR_PATH&amp;gt;&lt;/code&gt; is the path to your src directory&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; will delete all &lt;code class=&quot;highlighter-rouge&quot;&gt;**/__generated__/*.graphql.js&lt;/code&gt; files under &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_DIR_PATH&lt;/code&gt; before compilation starts&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Run the command to start compiling:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
npm run rcp
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-map-query-ids-on-the-server&quot;&gt;Step 3: Map query ids on the server&lt;/h2&gt;
&lt;p&gt;On the server, use &lt;code class=&quot;highlighter-rouge&quot;&gt;matchQueryMiddleware&lt;/code&gt; prior to &lt;code class=&quot;highlighter-rouge&quot;&gt;express-graphql&lt;/code&gt; to match query ids to actual queries. Note 
that &lt;code class=&quot;highlighter-rouge&quot;&gt;queryMap.json&lt;/code&gt; is auto-generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in the previous step.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
import Express from ‘express’;
import expressGraphl from ‘express-graphql’;
import {matchQueryMiddleware} from ‘relay-compiler-plus’; // do this
import queryMapJson from ‘../queryMap.json’; // do this&lt;/p&gt;

&lt;p&gt;const app = Express();&lt;/p&gt;

&lt;p&gt;app.use(‘/graphql’,
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-4-send-query-ids-on-the-client&quot;&gt;Step 4: Send query ids on the client&lt;/h2&gt;
&lt;p&gt;On the client, modify your relay network fetch implementation to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;queryId&lt;/code&gt; parameter in the
request body instead of a &lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; parameter. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;operation.id&lt;/code&gt; is generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in step 2.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function fetchQuery(operation, variables,) {
  return fetch(‘/graphql’, {
    method: ‘POST’,
    headers: {
      ‘content-type’: ‘application/json’
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response =&amp;gt; {
    return response.json();
  });
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;#step-2-compile&quot;&gt;step 2&lt;/a&gt;, running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcreteBatch&lt;/code&gt; query file and you’ll see that it now has an &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; assigned 
to it and that the query &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; is now &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
const batch /&lt;em&gt;: ConcreteBatch&lt;/em&gt;/ = {
  “fragment”: {
    “argumentDefinitions”: [],
    “kind”: “Fragment”,
    “metadata”: null,
    “name”: “client_index_Query”,
    “selections”: […],
    “type”: “Query”
  },
  “id”: “6082095e8a45f64d38924775d047cf8c”, // look ma, query id!
  “kind”: “Batch”,
  “metadata”: {},
  “name”: “client_index_Query”,
  “query”: {…},
  “text”: null // look again ma, null query text!
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The id is an md5 hash of the query text, generated by the &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js&quot; target=&quot;_blank&quot;&gt;persistQuery&lt;/a&gt; 
function. It looks like this:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
 function persistQuery(operationText: string): Promise&lt;string&gt; {
   return new Promise((resolve) =&amp;gt; {
     const queryId = md5(operationText);&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // queryCache is written to disk at the end as queryMap.json
 queryCache.push({id: queryId, text: operationText});
 resolve(queryId);    });  }    {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
&lt;a href=&quot;#step-3-map-query-ids-on-the-server&quot;&gt;step 3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You can find the package at &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; with a fully working
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me know if this is useful (or not)!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="async" />
<category term="generator" />
<category term="functions" />
<category term="iterator" />
<category term="yield" />
<category term="for-await-of" />
<category term="for" />
<category term="await" />
<category term="of" />
<summary>An exciting new feature of js is async generator functions. A normal function in javascript isrun from beginning till end i.e. run to completion. Once invoked, the entire bodyof the function is executed until the end is reached. You can’t stop or pause the execution of anordinary js function.</summary>
</entry>
<entry>
<title>Relay Modern Server Side Rendering</title>
<link href="http://reactjunkie.com/relay-modern-ssr/" rel="alternate" type="text/html" title="Relay Modern Server Side Rendering" />
<published>2018-01-09T07:30:00+11:00</published>
<updated>2018-01-09T07:30:00+11:00</updated>
<id>http://reactjunkie.com/relay-modern-ssr</id>
<content type="html" xml:base="http://reactjunkie.com/relay-modern-ssr/">&lt;p&gt;Relay modern is awesome, but unfortunately not much has been documented about how to use it with ssr. Facebook
does not use ssr with relay modern so it’s up to the community to do something about it. When I say community it’s
really just one man Jimmy Chia aka taion who has single-handedly written found router, farce and found relay to
make ssr possible with relay modern.&lt;/p&gt;

&lt;p&gt;If you are using react-router, you’re out of luck. You’ll need to jump the cliff and swap it out with found. I have 
done it and I never look back. Found is very similar to react router v3, so you won’t have any problems switching.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Create a relay modern app with ssr with found and found relay.&lt;/p&gt;

&lt;h2 id=&quot;step-1-install-npm-packages&quot;&gt;Step 1: Install npm packages&lt;/h2&gt;
&lt;p&gt;Install babel-polyfill (for async await), found and found relay&lt;/p&gt;

&lt;h2 id=&quot;step-2-create-routes&quot;&gt;Step 2: Create routes&lt;/h2&gt;
&lt;p&gt;create routes, makeRouteConfig, export that routeConfig object.
createBrowserRouter using routeConfig object.&lt;/p&gt;

&lt;h2 id=&quot;step-3-ssr&quot;&gt;Step 3: SSR&lt;/h2&gt;
&lt;p&gt;use the same routes object
on the client bootstrap use createInitialBrowserRouter instead and await on that
u also need createRender function (TODO: investigate why?)&lt;/p&gt;

&lt;p&gt;On the server, await getFarceResult from found/lib/server passing in url, routeConfig and 
render method to get the output data from the requested route.&lt;/p&gt;

&lt;p&gt;Then renderToString the element property from the output. That’s it!&lt;/p&gt;

&lt;p&gt;Without redux, it’s soo much cleaner!&lt;/p&gt;

&lt;p&gt;Install relay-compiler-plus and the latest &lt;a href=&quot;https://github.com/graphql/graphql-js&quot; target=&quot;_blank&quot;&gt;graphql-js&lt;/a&gt; package:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add relay-compiler-plus
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn upgrade graphql –latest
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-compile&quot;&gt;Step 2: Compile&lt;/h2&gt;
&lt;p&gt;Add this npm command to your &lt;strong&gt;package.json&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
“scripts”: {
    “rcp”: “relay-compiler-plus –schema &lt;schema_file_path&gt; --src &lt;src_dir_path&gt; -f&quot;
},
{% endhighlight %}&lt;/src_dir_path&gt;&lt;/schema_file_path&gt;&lt;/p&gt;

&lt;p&gt;where:&lt;br /&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SCHEMA_FILE_PATH&amp;gt;&lt;/code&gt; is the path to your schema.graphql or schema.json file&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SRC_DIR_PATH&amp;gt;&lt;/code&gt; is the path to your src directory&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; will delete all &lt;code class=&quot;highlighter-rouge&quot;&gt;**/__generated__/*.graphql.js&lt;/code&gt; files under &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_DIR_PATH&lt;/code&gt; before compilation starts&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Run the command to start compiling:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
npm run rcp
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-map-query-ids-on-the-server&quot;&gt;Step 3: Map query ids on the server&lt;/h2&gt;
&lt;p&gt;On the server, use &lt;code class=&quot;highlighter-rouge&quot;&gt;matchQueryMiddleware&lt;/code&gt; prior to &lt;code class=&quot;highlighter-rouge&quot;&gt;express-graphql&lt;/code&gt; to match query ids to actual queries. Note 
that &lt;code class=&quot;highlighter-rouge&quot;&gt;queryMap.json&lt;/code&gt; is auto-generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in the previous step.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
import Express from ‘express’;
import expressGraphl from ‘express-graphql’;
import {matchQueryMiddleware} from ‘relay-compiler-plus’; // do this
import queryMapJson from ‘../queryMap.json’; // do this&lt;/p&gt;

&lt;p&gt;const app = Express();&lt;/p&gt;

&lt;p&gt;app.use(‘/graphql’,
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-4-send-query-ids-on-the-client&quot;&gt;Step 4: Send query ids on the client&lt;/h2&gt;
&lt;p&gt;On the client, modify your relay network fetch implementation to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;queryId&lt;/code&gt; parameter in the
request body instead of a &lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; parameter. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;operation.id&lt;/code&gt; is generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in step 2.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function fetchQuery(operation, variables,) {
  return fetch(‘/graphql’, {
    method: ‘POST’,
    headers: {
      ‘content-type’: ‘application/json’
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response =&amp;gt; {
    return response.json();
  });
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;#step-2-compile&quot;&gt;step 2&lt;/a&gt;, running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcreteBatch&lt;/code&gt; query file and you’ll see that it now has an &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; assigned 
to it and that the query &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; is now &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
const batch /&lt;em&gt;: ConcreteBatch&lt;/em&gt;/ = {
  “fragment”: {
    “argumentDefinitions”: [],
    “kind”: “Fragment”,
    “metadata”: null,
    “name”: “client_index_Query”,
    “selections”: […],
    “type”: “Query”
  },
  “id”: “6082095e8a45f64d38924775d047cf8c”, // look ma, query id!
  “kind”: “Batch”,
  “metadata”: {},
  “name”: “client_index_Query”,
  “query”: {…},
  “text”: null // look again ma, null query text!
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The id is an md5 hash of the query text, generated by the &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js&quot; target=&quot;_blank&quot;&gt;persistQuery&lt;/a&gt; 
function. It looks like this:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
 function persistQuery(operationText: string): Promise&lt;string&gt; {
   return new Promise((resolve) =&amp;gt; {
     const queryId = md5(operationText);&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // queryCache is written to disk at the end as queryMap.json
 queryCache.push({id: queryId, text: operationText});
 resolve(queryId);    });  }    {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
&lt;a href=&quot;#step-3-map-query-ids-on-the-server&quot;&gt;step 3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You can find the package at &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; with a fully working
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me know if this is useful (or not)!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="relay" />
<category term="modern" />
<category term="ssr" />
<category term="server" />
<category term="side" />
<category term="rendering" />
<category term="redux" />
<summary>Relay modern is awesome, but unfortunately not much has been documented about how to use it with ssr. Facebookdoes not use ssr with relay modern so it’s up to the community to do something about it. When I say community it’sreally just one man Jimmy Chia aka taion who has single-handedly written found router, farce and found relay tomake ssr possible with relay modern.</summary>
</entry>
<entry>
<title>Relay Modern Persisted Queries</title>
<link href="http://reactjunkie.com/relay-modern-persisted-queries/" rel="alternate" type="text/html" title="Relay Modern Persisted Queries" />
<published>2017-11-12T07:30:00+11:00</published>
<updated>2017-11-12T07:30:00+11:00</updated>
<id>http://reactjunkie.com/relay-modern-persisted-queries</id>
<content type="html" xml:base="http://reactjunkie.com/relay-modern-persisted-queries/">&lt;p&gt;This blog is about &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;relay-compiler-plus&lt;/a&gt;, 
a custom relay compiler which supports persisted queries.&lt;/p&gt;

&lt;p&gt;One of the more exciting features of relay modern is the ability to use persisted queries with the graphql server.
Instead of sending the full graphql query in the request payload, you send a short query id which gets mapped
on the server side to the full query. It’s a no-brainer for performance. I upgraded from classic for this!&lt;/p&gt;

&lt;p&gt;Alas, the official &lt;a href=&quot;https://facebook.github.io/relay/docs/new-in-relay-modern.html&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt;
only briefly mentioned this without anything else. A quick google search reveals a solution from 
&lt;a href=&quot;https://medium.com/@wonderboymusic/upgrading-to-relay-modern-or-apollo-ffa58d3a5d59&quot; target=&quot;_blank&quot;&gt;Scott Taylor&lt;/a&gt;
from the New York Times. However his solution generates query ids at runtime at the network fetch level which is not
optimal. I want a solution where the query ids and the query map file are both generated at compile time for maximum
performance.&lt;/p&gt;

&lt;p&gt;It turns out, the original relay-compiler does have a hidden feature to support persisted queries.&lt;/p&gt;

&lt;p&gt;This package is inspired by a conversation with &lt;a href=&quot;https://github.com/leebyron&quot; target=&quot;_blank&quot;&gt;Lee Byron&lt;/a&gt; 
at &lt;a href=&quot;https://summit.graphql.com/&quot; target=&quot;_blank&quot;&gt;Graphql Summit 2017&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-key&quot;&gt;The key&lt;/h2&gt;
&lt;p&gt;The key lies in &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/codegen/RelayFileWriter.js&quot; target=&quot;_blank&quot;&gt;RelayFileWriter&lt;/a&gt;.
It accepts a config object where you can specify a &lt;code class=&quot;highlighter-rouge&quot;&gt;persistQuery&lt;/code&gt; function. You can dig around and peruse
that code at your leisure (which I did). The end result is a modification to the relay-compiler which
accepts a &lt;code class=&quot;highlighter-rouge&quot;&gt;persistQuery&lt;/code&gt; function which gets passed down to &lt;code class=&quot;highlighter-rouge&quot;&gt;RelayFileWriter&lt;/code&gt;. I call it 
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;relay-compiler-plus&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;step-1-install&quot;&gt;Step 1: Install&lt;/h2&gt;
&lt;p&gt;Install relay-compiler-plus and the latest &lt;a href=&quot;https://github.com/graphql/graphql-js&quot; target=&quot;_blank&quot;&gt;graphql-js&lt;/a&gt; package:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add relay-compiler-plus
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn upgrade graphql –latest
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-compile&quot;&gt;Step 2: Compile&lt;/h2&gt;
&lt;p&gt;Add this npm command to your &lt;strong&gt;package.json&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
“scripts”: {
    “rcp”: “relay-compiler-plus –schema &lt;schema_file_path&gt; --src &lt;src_dir_path&gt; -f&quot;
},
{% endhighlight %}&lt;/src_dir_path&gt;&lt;/schema_file_path&gt;&lt;/p&gt;

&lt;p&gt;where:&lt;br /&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SCHEMA_FILE_PATH&amp;gt;&lt;/code&gt; is the path to your schema.graphql or schema.json file&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SRC_DIR_PATH&amp;gt;&lt;/code&gt; is the path to your src directory&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; will delete all &lt;code class=&quot;highlighter-rouge&quot;&gt;**/__generated__/*.graphql.js&lt;/code&gt; files under &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_DIR_PATH&lt;/code&gt; before compilation starts&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Run the command to start compiling:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
npm run rcp
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-map-query-ids-on-the-server&quot;&gt;Step 3: Map query ids on the server&lt;/h2&gt;
&lt;p&gt;On the server, use &lt;code class=&quot;highlighter-rouge&quot;&gt;matchQueryMiddleware&lt;/code&gt; prior to &lt;code class=&quot;highlighter-rouge&quot;&gt;express-graphql&lt;/code&gt; to match query ids to actual queries. Note 
that &lt;code class=&quot;highlighter-rouge&quot;&gt;queryMap.json&lt;/code&gt; is auto-generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in the previous step.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
import Express from ‘express’;
import expressGraphl from ‘express-graphql’;
import {matchQueryMiddleware} from ‘relay-compiler-plus’; // do this
import queryMapJson from ‘../queryMap.json’; // do this&lt;/p&gt;

&lt;p&gt;const app = Express();&lt;/p&gt;

&lt;p&gt;app.use(‘/graphql’,
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-4-send-query-ids-on-the-client&quot;&gt;Step 4: Send query ids on the client&lt;/h2&gt;
&lt;p&gt;On the client, modify your relay network fetch implementation to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;queryId&lt;/code&gt; parameter in the
request body instead of a &lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; parameter. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;operation.id&lt;/code&gt; is generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in step 2.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function fetchQuery(operation, variables,) {
  return fetch(‘/graphql’, {
    method: ‘POST’,
    headers: {
      ‘content-type’: ‘application/json’
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response =&amp;gt; {
    return response.json();
  });
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;#step-2-compile&quot;&gt;step 2&lt;/a&gt;, running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcreteBatch&lt;/code&gt; query file and you’ll see that it now has an &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; assigned 
to it and that the query &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; is now &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
const batch /&lt;em&gt;: ConcreteBatch&lt;/em&gt;/ = {
  “fragment”: {
    “argumentDefinitions”: [],
    “kind”: “Fragment”,
    “metadata”: null,
    “name”: “client_index_Query”,
    “selections”: […],
    “type”: “Query”
  },
  “id”: “6082095e8a45f64d38924775d047cf8c”, // look ma, query id!
  “kind”: “Batch”,
  “metadata”: {},
  “name”: “client_index_Query”,
  “query”: {…},
  “text”: null // look again ma, null query text!
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The id is an md5 hash of the query text, generated by the &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js&quot; target=&quot;_blank&quot;&gt;persistQuery&lt;/a&gt; 
function. It looks like this:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
 function persistQuery(operationText: string): Promise&lt;string&gt; {
   return new Promise((resolve) =&amp;gt; {
     const queryId = md5(operationText);&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // queryCache is written to disk at the end as queryMap.json
 queryCache.push({id: queryId, text: operationText});
 resolve(queryId);    });  }    {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
&lt;a href=&quot;#step-3-map-query-ids-on-the-server&quot;&gt;step 3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You can find the package at &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; with a fully working
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me know if this is useful (or not)!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="relay" />
<category term="modern" />
<category term="persisted" />
<category term="queries" />
<category term="graphql" />
<category term="javascript" />
<category term="js" />
<summary>This blog is about relay-compiler-plus, a custom relay compiler which supports persisted queries.</summary>
</entry>
<entry>
<title>Javascript Job Queues and Promises</title>
<link href="http://reactjunkie.com/promises-promises/" rel="alternate" type="text/html" title="Javascript Job Queues and Promises" />
<published>2017-09-18T07:30:00+10:00</published>
<updated>2017-09-18T07:30:00+10:00</updated>
<id>http://reactjunkie.com/promises-promises</id>
<content type="html" xml:base="http://reactjunkie.com/promises-promises/">&lt;p&gt;So you think you know how promises work? Someone ever comes to you
with a little trivia called “what’s the sequence of console logs from this
piece of async code”? And no matter how hard you try you never get
it right?&lt;/p&gt;

&lt;p&gt;I experienced this at work last week and in process learnt something new about
promises which I would like to share.&lt;/p&gt;

&lt;p&gt;There are few (if any) that explain the scheduling aspects of Promises though.
Perhaps because it’s not a hot topic. It’s too low level. You need a
shot of vodka to understand it. Bla bla.. so here goes nothing.&lt;/p&gt;

&lt;p&gt;This is not an intro to promises or how to use them. There are plenty
of blogs out there explaining that in complete pornographic detail (give me
that vodka!). No sir, today I’ll be talking about the temporal aspects
of promises i.e. “when” your code gets executed and why.&lt;/p&gt;

&lt;p&gt;It’s actually very interesting!&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Understand when parts of your promise gets executed and why.&lt;/p&gt;

&lt;h2 id=&quot;step-1-anatomy-of-a-promise&quot;&gt;Step 1: Anatomy of a Promise&lt;/h2&gt;
&lt;script src=&quot;https://gist.github.com/yusinto/28295371fc7613f66fab39f0c7435c54.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Wanna guess what the output is? You can run the code &lt;a href=&quot;https://repl.it/repls/WelloffSeveralPlatypus&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;
and see for yourself. Or I can just tell you. It is: 1 3 4 6 2 5.&lt;/p&gt;

&lt;p&gt;It doesn’t matter if you guessed right or wrong. It matters if you understand why this is the output.&lt;/p&gt;

&lt;h2 id=&quot;step-2-the-executor&quot;&gt;Step 2: The executor&lt;/h2&gt;
&lt;p&gt;It is always run immediately! The moment you new up a Promise, the function
you specify in the constructor i.e. the executor gets run immediately in the current tick.&lt;/p&gt;

&lt;p&gt;So 1 gets printed, then resolve gets called. Calling resolve marks the promise as
fulfilled and that’s it. It does not trigger anything else.&lt;/p&gt;

&lt;p&gt;Then 3 gets printed. The current tick continues out of the promise constructor and prints 4.&lt;/p&gt;

&lt;h2 id=&quot;step-3-then&quot;&gt;Step 3: .then&lt;/h2&gt;
&lt;p&gt;This is the interesting part. Remember the promise was resolved? When you
call .then on a resolved promise, the success handler gets scheduled in
the job queue. What the hell? What’s a job queue? Never heard of it. Am
I making this shit up? It’s &lt;a href=&quot;https://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues&quot; target=&quot;_blank&quot;&gt;real&lt;/a&gt;
my friend. Keep reading.&lt;/p&gt;

&lt;h2 id=&quot;step-4-the-job-queue&quot;&gt;Step 4: The job queue&lt;/h2&gt;
&lt;p&gt;You must be familiar with the event loop and the event queue (if not, google them!)?
This gives javascript that infamous single-threaded reputation. Each iteration
of this loop is called a “tick”. Each tick processes a message from the event queue.
So is the event queue the same as the job queue?&lt;/p&gt;

&lt;p&gt;No it is not. The job queue is a completely separate queue. More importantly,
messages in this queue are processed immediately at the end of each tick
before the beginning of the next tick. Each tick has its own job queue.&lt;/p&gt;

&lt;p&gt;It’s like jumping the event queue. Success handlers for promises are
scheduled into this job queue. They get executed before the next message
in the event queue.&lt;/p&gt;

&lt;p&gt;So with this newfound wisdom, our success handler above gets scheduled
in the job queue, to be run at the end of the tick.&lt;/p&gt;

&lt;h2 id=&quot;step-5-what-goes-into-the-event-queue&quot;&gt;Step 5: What goes into the event queue?&lt;/h2&gt;

&lt;p&gt;Glad you asked. Things like setTimeout callbacks and event listeners are
scheduled into the event queue. So in our example above, console.log(5)
is scheduled into the event queue, even when the delay is 0ms. That means
this gets run after the success handler because the event queue is processed
in the next tick.&lt;/p&gt;

&lt;h2 id=&quot;step-6-booooringg&quot;&gt;Step 6: Booooringg&lt;/h2&gt;

&lt;p&gt;Ok ok last we saw our program, it output 4, so what’s next? We saw .then
and setTimeout are asynchronous i.e. they get scheduled into the job queue
and the event queue respectively, so the current tick continues and executes
console.log(6). The tick ends, or has it? We still have the job queue at
the of the tick, so no it has not ended yet.&lt;/p&gt;

&lt;p&gt;Our program then executes the success handler, which is the first and only
job in the job queue. This outputs 2. Then the tick ends.&lt;/p&gt;

&lt;p&gt;Finally our program continues to the next tick and executes console.log(5).
The end!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Best have lotsa vodka when talking about promises. Thanks for reading!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="javascript" />
<category term="promises" />
<category term="job" />
<category term="queues" />
<category term="js" />
<category term="asynchronous" />
<category term="event" />
<category term="loop" />
<summary>So you think you know how promises work? Someone ever comes to youwith a little trivia called “what’s the sequence of console logs from thispiece of async code”? And no matter how hard you try you never getit right?</summary>
</entry>
</feed>
