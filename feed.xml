<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.0.3">Jekyll</generator>
<link href="http://reactjunkie.com/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://reactjunkie.com/" rel="alternate" type="text/html" />
<updated>2018-03-22T10:53:26+11:00</updated>
<id>http://reactjunkie.com/</id>
<title>React Junkie - Yusinto Ngadiman&#39;s Blog</title>
<entry>
<title>Docker is dead long live Kubernetes</title>
<link href="http://reactjunkie.com/docker-is-dead/" rel="alternate" type="text/html" title="Docker is dead long live Kubernetes" />
<published>2018-02-28T07:30:00+11:00</published>
<updated>2018-02-28T07:30:00+11:00</updated>
<id>http://reactjunkie.com/docker-is-dead</id>
<content type="html" xml:base="http://reactjunkie.com/docker-is-dead/">&lt;p&gt;&lt;strong&gt;Update 22 Mar 2018&lt;/strong&gt;: Fixed cloudbuild.yaml to generate a docker tag every time otherwise kubernetes does not detect changes.&lt;/p&gt;

&lt;p&gt;Kubernetes rocks. Kubernetes engine to be exact. I was so inspired by Kelsey Hightower’s
&lt;a href=&quot;https://www.youtube.com/watch?v=kOa_llowQ1c&amp;amp;feature=youtu.be&quot; target=&quot;_blank&quot;&gt;presentation&lt;/a&gt; at KubeCon 2017 I
spent the next 2 weeks migrating my entire pipeline from Jenkins/AWS/Terraform to Google Cloud Platform (GCP for short) 
and the Kubernetes Engine. It’s the best decision I have ever made.&lt;/p&gt;

&lt;p&gt;Ok so the title is a little dramatic. Kubernetes uses docker so it doesn’t actually really kill docker, it merely pushes
it further into the background. That means you are free to focus on the bigger picture, which is your end to end pipeline
and your code. During my migration, I found that apart from the dockerfile and a docker build, I didn’t really have to
touch docker much. It’s a sign that the docker stack has matured.&lt;/p&gt;

&lt;p&gt;In this blog I’ll walk you through how to set up a continuous dev pipeline on GCP and the Kubernetes Engine.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;During development, the dev test cycle is predictable and well-defined. You write code, it runs locally and pass all the 
tests then you push your code to git. The &lt;em&gt;intent&lt;/em&gt; is clear. Pushing to git means you want to see that code running on an 
environment somewhere. This environment should also be predictable and well-defined. Without doing any more work, you
should be able to open your browser and run the code you just pushed in this well-defined environment.&lt;/p&gt;

&lt;p&gt;The goal of this tutorial is to build a pipeline that does exactly that. At the end of this post, you should be able to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Create a new feature off master, code and test locally.&lt;/li&gt;
  &lt;li&gt;Push to git.&lt;/li&gt;
  &lt;li&gt;Browse to a well-defined feature url which has the new code running.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;step-1-create-a-kubernetes-cluster&quot;&gt;Step 1: Create a Kubernetes cluster&lt;/h2&gt;
&lt;p&gt;Jump into google cloud console and under the main menu, go to Compute -&amp;gt; Kubernetes Engine -&amp;gt; Kubernetes clusters and
click on Create Cluster. You’ll see a screen like below, you only need to touch 3 fields:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/create-cluster.png&quot; alt=&quot;Create Kubernetes cluster&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Name your cluster &lt;em&gt;feature-cluster&lt;/em&gt;. When we push to git, we’ll deploy our feature to nodes running on this cluster.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pick a zone that’s closest to you. The Zonal and Regional option refers to the location of your Kubernetes master. 
Zonal means your master service will be running in a single zone that you picked. Regional means your master service 
will be running in multiple zones in that region for redundancy. To keep things simple for this demo we’ll stick with zonal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pick the latest cluster version to get all the latest features.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Leave the remaining default settings e.g. 3 nodes in the cluster on Container-Optimised OS and click create. It takes 
some time for google to create your cluster because it has to provision the nodes. While that’s cooking, we’ll create 
the build job.&lt;/p&gt;

&lt;h2 id=&quot;step-2-create-a-build-trigger&quot;&gt;Step 2: Create a build trigger&lt;/h2&gt;
&lt;p&gt;In the console menu, go to Tools -&amp;gt; Container Registry -&amp;gt; Build triggers. Add a new trigger. Select your git source
(I use github) and repo and authorise container builder to access it. Then you’ll get to the
Edit Trigger page like below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/create-trigger.png&quot; alt=&quot;Container builder trigger settings&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Give your trigger a name, I name mine &lt;em&gt;feature&lt;/em&gt; because it gets triggered by a feature push and builds and deploys 
that feature.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set the trigger type to branch, because we want to trigger a build when a feature branch push happens. There is also
an option to trigger on tag push, which is useful for production deployment (when you create a release tag) but we’ll
cover that in a future post.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set a regex to match the feature branch names. By convention I enforce the following convention for features:
feature-[JIRA_TICKET_NUMBER]-description. All the developers follow this naming convention when they create a new
feature branch. Once a convention is in place, you can set a regex expression here to match your feature branches.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You define your build steps in the cloudbuild.yaml file. Set the location of &lt;em&gt;cloudbuild.yaml&lt;/em&gt; so container builder
can find it in your repo. I set mine to the root of my repo.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;step-3-cloudbuildyaml&quot;&gt;Step 3: cloudbuild.yaml&lt;/h2&gt;
&lt;p&gt;Container builder uses this file to execute a series of steps to build and deploy your app. Each build step specified
here is a container running in its own shell. For our demo, we’ll use the cloudbuild.yaml below:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/3922f40d0b8d0241b6c6ead1a9aa8f3f.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;There are 3 build steps in our cloudbuild.yaml file. Each step has a name and and an id. The name field refers to a
docker image that the build step will pull and run to execute the step. Container builder supports a &lt;a href=&quot;https://github.com/GoogleCloudPlatform/cloud-builders&quot; target=&quot;_blank&quot;&gt;common set of builder
images&lt;/a&gt; you can use as build steps. There are also &lt;a href=&quot;https://github.com/GoogleCloudPlatform/cloud-builders-community&quot; target=&quot;_blank&quot;&gt;community
images&lt;/a&gt;. In this example we’ll only
use google builder steps because it’s more than sufficient for our needs.&lt;/p&gt;

&lt;p&gt;The id field is optional but useful to specify because it will be displayed in the build logs. Otherwise you’ll see the
name field instead, which is not as informative. Also by specifying an id,
you can make subsequent build steps to waitFor this build step so those child steps can run concurrently. Speed up baby! So cool!&lt;/p&gt;

&lt;p&gt;In the first step, we generate a random tag (based on an md5 hash of the current timestamp) for our docker image. Don’t always tag
your images as latest because if the tag is unchanged, kubernetes won’t be able to detect that the image has been updated
and won’t update your pods. We output the md5 hash to a text file in the checkout directory. The checkout directory
persists across steps so we can access this text file later in subsequent steps.&lt;/p&gt;

&lt;p&gt;In the second step we build and push our docker image. We get the md5 hash from step 1 above and save it
to a shell variable. We can then use this to build and push our docker image.&lt;/p&gt;

&lt;p&gt;Now we are ready to deploy our image!&lt;/p&gt;

&lt;h2 id=&quot;step-4-deployment-templateyaml&quot;&gt;Step 4: deployment-template.yaml&lt;/h2&gt;
&lt;p&gt;Let’s take a look at the third step which runs kubectl. This step deploys our docker image to the Kubernetes cluster. Note
that this step runs the &lt;strong&gt;gcr.io/cloud-builders/kubectl&lt;/strong&gt; image, but we specified the
entrypoint as bash meaning that the container will run the bash command when it starts rather
than kubectl. This is a useful technique if you need to pre-run some commands prior to executing
the main command. We’ll come back to this in a minute after inspecting deployment-template.yaml:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yusinto/9536fa7dcd28106efee7f8b217a9d06a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;This is a standard kubernetes resource yaml specifying two resources to be created/updated in the cluster:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A deployment containing our pod spec&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A service to expose our pods to the external world so that it’s accessible via the internet.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We use a placeholder string _BRANCH_NAME and _TAG which gets replaced by the real $BRANCH_NAME and our md5 hash using the sed command
in our build step:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
sed -e “s|_BRANCH_NAME|$BRANCH_NAME|g” -e “s|_TAG|$tag|g” deployment-template.yaml | tee deployment.yaml
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Like in the previous docker-build-push step, we get the tag from the md5 hash from step 1. $BRANCH_NAME is injected by 
the Container Builder as an environment variable to all build steps. This is the git branch name that triggers the build. 
There are &lt;a href=&quot;https://cloud.google.com/container-builder/docs/configuring-builds/substitute-variable-values&quot; target=&quot;_blank&quot;&gt;other environment variables&lt;/a&gt; 
you can use.&lt;/p&gt;

&lt;p&gt;This produces a new &lt;code class=&quot;highlighter-rouge&quot;&gt;deployment.yaml&lt;/code&gt; which gets used by &lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; for deployment:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
kubectl apply -f deployment.yaml
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This way, we can deploy each branch to its own infrastructure mirroring our git branching strategy.&lt;/p&gt;

&lt;h2 id=&quot;step-5-test-the-app&quot;&gt;Step 5: Test the app!&lt;/h2&gt;
&lt;p&gt;Push a git commit to a feature branch and watch the magic happens! It takes a while for google cloud to assign an external 
ip to our service. You can check under Compute -&amp;gt; Kubernetes Engine -&amp;gt; Discovery &amp;amp; load balancing. The &lt;em&gt;Endpoints&lt;/em&gt; column 
should display a valid external ip when it’s ready. Then you can hit that link and your app should be running!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Deploying my app used to involve many moving parts: Jenkins, ec2 instances, load balancers, terraform, ecs. Kubernetes Engine
greatly simplifies this by encapsulating many of the moving parts. When used in conjunction with Container Builder, the 
dream of a continuous end to end build pipeline suddenly becomes somewhat easier to achieve. This is just the tip of the
iceberg, I am so excited!&lt;/p&gt;

&lt;p&gt;In part two of this series I’ll walk you through the teardown process to complete the feature development pipeline. 
You don’t want unused resources running in the cloud burning your wallet! Till next time.&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="docker" />
<category term="kubernetes" />
<category term="engine" />
<category term="google" />
<category term="cloud" />
<category term="platform" />
<category term="ci" />
<category term="cd" />
<category term="continuous" />
<category term="deployment" />
<category term="integration" />
<category term="build" />
<category term="pipeline" />
<category term="end" />
<category term="to" />
<category term="end" />
<summary>Update 22 Mar 2018: Fixed cloudbuild.yaml to generate a docker tag every time otherwise kubernetes does not detect changes.</summary>
</entry>
<entry>
<title>Launch Darkly, React and Redux: The Easy Way</title>
<link href="http://reactjunkie.com/ld-redux-v3/" rel="alternate" type="text/html" title="Launch Darkly, React and Redux: The Easy Way" />
<published>2018-01-14T07:30:00+11:00</published>
<updated>2018-01-14T07:30:00+11:00</updated>
<id>http://reactjunkie.com/ld-redux-v3</id>
<content type="html" xml:base="http://reactjunkie.com/ld-redux-v3/">&lt;p&gt;About a year and a bit ago I published ld-redux to integrate launch darkly with react and redux. I used that solution
both commercially in production and personally. It has been stable thus far. There were issues though:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ld-redux state contains a somewhat mysterious internal property called &lt;em&gt;isLDReady&lt;/em&gt; which is a pain in the butt.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;components have to be connected via a hoc called &lt;em&gt;ldConnect&lt;/em&gt; which is again a pain.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The subscription logic for flag changes in that hoc might result in duplicate subscriptions which is inefficient.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these in mind, I introduce to you (drum roll) &lt;a href=&quot;https://github.com/yusinto/ld-redux&quot; target=&quot;_blank&quot;&gt;ld-redux v3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;whats-new&quot;&gt;What’s new?&lt;/h2&gt;
&lt;p&gt;There’s no longer need to worry about &lt;em&gt;isLDReady&lt;/em&gt;. It has been deleted completely from the package.&lt;/p&gt;

&lt;p&gt;There’s no longer need to connect using &lt;em&gt;ldConnect&lt;/em&gt; either! It is gone baby gone!&lt;/p&gt;

&lt;p&gt;You can consume your flags directly from your redux store without having to use &lt;em&gt;getFlags()&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The subscription logic has been moved to the &lt;em&gt;init()&lt;/em&gt; method so all subscriptions are done just once. Very efficient.&lt;/p&gt;

&lt;h1 style=&quot;color: red&quot;&gt;!!WARNING!!&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/steve-jobs-small.jpg&quot; alt=&quot;Backwards compatibility?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;v3 is &lt;strong&gt;NOT&lt;/strong&gt; backwards compatible with v1.x! So be prepared to do some refactoring if you are on v1 upgrading to v3.
It’s a simple upgrade though. You will be deleting code most of the time. ld-redux v3 is launch darkly 
and redux as it’s meant to be!&lt;/p&gt;

&lt;h2 id=&quot;how-to-use&quot;&gt;How to use?&lt;/h2&gt;
&lt;p&gt;You include ldReducer in your app and call the init method once at bootstrap. Your flags will then be available
in your redux state as camel cased keys. That’s it!&lt;/p&gt;

&lt;h4 id=&quot;clientbootstrapjs&quot;&gt;clientBootstrap.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
import createStore from ‘&lt;your-project&gt;/store&#39;;
import ldRedux from &#39;ld-redux&#39;;&lt;/your-project&gt;&lt;/p&gt;

&lt;p&gt;// standard redux createStore
const store = createStore();&lt;/p&gt;

&lt;p&gt;// Tip: you can declare your flags inline or import it as a json file
const flags = { ‘feature-flag-key’: false };&lt;/p&gt;

&lt;p&gt;// Init once on bootstrap to set default flag values and subscriptions
ldRedux.init({
  clientSideId: ‘your-client-side-id’,
  store,
  flags,
});&lt;/p&gt;

&lt;p&gt;render(
  &amp;lt;Provider store={store}&amp;gt;
    &amp;lt;Router routes={routes} history={browserHistory}/&amp;gt;
  &amp;lt;/Provider&amp;gt;,
  document.getElementById(‘reactDiv’)
);
{% endhighlight %}&lt;/p&gt;

&lt;h4 id=&quot;reducerjs&quot;&gt;reducer.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
import { combineReducers } from ‘redux’;
import ldRedux from ‘ld-redux’;
import reducers from ‘&lt;your-project&gt;/reducers&#39;;&lt;/your-project&gt;&lt;/p&gt;

&lt;p&gt;// Note: the LD key can be anything you want
export default combineReducers({
  …reducers,
  LD: ldRedux.reducer(),
});
{% endhighlight %}&lt;/p&gt;

&lt;h4 id=&quot;yourcomponentjs&quot;&gt;yourComponent.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
…&lt;/p&gt;

&lt;p&gt;const mapStateToProps = (state) =&amp;gt; {
  // Your camelCased feature flags are magically available in the store!
  // Note: the key LD must be the same as step 2
  const {featureFlagKey} = state.LD;&lt;/p&gt;

&lt;p&gt;return {
    featureFlagKey,
  };
};&lt;/p&gt;

&lt;p&gt;…
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Check the fully working &lt;a href=&quot;https://github.com/yusinto/ld-redux/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt; on github.&lt;/p&gt;

&lt;p&gt;Oh and one more thing in case someone asks what happened to ld-redux v2? It went from v1.4.x to v3.0.1. What the heck?
Umm I made a mistake during publishing (entered npm version update major twice) so it became v3. Doesn’t matter! As long
as it works right?&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="launch" />
<category term="darkly" />
<category term="react" />
<category term="redux" />
<category term="feature" />
<category term="flags" />
<category term="toggle" />
<summary>About a year and a bit ago I published ld-redux to integrate launch darkly with react and redux. I used that solutionboth commercially in production and personally. It has been stable thus far. There were issues though:</summary>
</entry>
<entry>
<title>Async Generator Functions</title>
<link href="http://reactjunkie.com/async-generator-functions/" rel="alternate" type="text/html" title="Async Generator Functions" />
<published>2018-01-14T07:30:00+11:00</published>
<updated>2018-01-14T07:30:00+11:00</updated>
<id>http://reactjunkie.com/async-generator-functions</id>
<content type="html" xml:base="http://reactjunkie.com/async-generator-functions/">&lt;p&gt;An exciting new feature of js is async generator functions. A normal function in javascript is
run from beginning till end i.e. run to completion. Once invoked, the entire body
of the function is executed until the end is reached. You can’t stop or pause the execution of an
ordinary js function.&lt;/p&gt;

&lt;p&gt;Generator functions however, does not run to completion. You use the yield keyword to pause function
execution and then the next() method to continue execution.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Use async generator functions right now with babel.&lt;/p&gt;

&lt;h2 id=&quot;step-1-what-is-a-generator-function&quot;&gt;Step 1: What is a generator function?&lt;/h2&gt;
&lt;p&gt;A generator function is a function which returns an iterator when run.
An iterator is an object that has a next() method implemented returning an object { value, done }.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function* () {
    console.log(1);
    let temp = yield “first yield”;
    console.log(temp);
    yield “second yield”;
    return;
} 
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-what-is-an-async-generator-function&quot;&gt;Step 2: What is an async generator function?&lt;/h2&gt;
&lt;p&gt;Is the same as a generator function, BUT iterator.next() returns a promise returning the { value, done } object.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
async function* () {
    console.log(1);
    let temp = yield “first yield”;
    console.log(temp);
    yield “second yield”;
    return;
} 
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-how-to-use-async-generator-with-babel&quot;&gt;Step 3: How to use async generator with babel&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
yarn add –dev babel-plugin-transform-async-to-generator babel-plugin-transform-async-generator-functions
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Then in your .babelrc file:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
{
  “plugins”: [
    “transform-async-to-generator”,
    “transform-async-generator-functions”
  ]
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Install relay-compiler-plus and the latest &lt;a href=&quot;https://github.com/graphql/graphql-js&quot; target=&quot;_blank&quot;&gt;graphql-js&lt;/a&gt; package:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add relay-compiler-plus
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn upgrade graphql –latest
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-compile&quot;&gt;Step 2: Compile&lt;/h2&gt;
&lt;p&gt;Add this npm command to your &lt;strong&gt;package.json&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
“scripts”: {
    “rcp”: “relay-compiler-plus –schema &lt;schema_file_path&gt; --src &lt;src_dir_path&gt; -f&quot;
},
{% endhighlight %}&lt;/src_dir_path&gt;&lt;/schema_file_path&gt;&lt;/p&gt;

&lt;p&gt;where:&lt;br /&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SCHEMA_FILE_PATH&amp;gt;&lt;/code&gt; is the path to your schema.graphql or schema.json file&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SRC_DIR_PATH&amp;gt;&lt;/code&gt; is the path to your src directory&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; will delete all &lt;code class=&quot;highlighter-rouge&quot;&gt;**/__generated__/*.graphql.js&lt;/code&gt; files under &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_DIR_PATH&lt;/code&gt; before compilation starts&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Run the command to start compiling:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
npm run rcp
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-map-query-ids-on-the-server&quot;&gt;Step 3: Map query ids on the server&lt;/h2&gt;
&lt;p&gt;On the server, use &lt;code class=&quot;highlighter-rouge&quot;&gt;matchQueryMiddleware&lt;/code&gt; prior to &lt;code class=&quot;highlighter-rouge&quot;&gt;express-graphql&lt;/code&gt; to match query ids to actual queries. Note 
that &lt;code class=&quot;highlighter-rouge&quot;&gt;queryMap.json&lt;/code&gt; is auto-generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in the previous step.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
import Express from ‘express’;
import expressGraphl from ‘express-graphql’;
import {matchQueryMiddleware} from ‘relay-compiler-plus’; // do this
import queryMapJson from ‘../queryMap.json’; // do this&lt;/p&gt;

&lt;p&gt;const app = Express();&lt;/p&gt;

&lt;p&gt;app.use(‘/graphql’,
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-4-send-query-ids-on-the-client&quot;&gt;Step 4: Send query ids on the client&lt;/h2&gt;
&lt;p&gt;On the client, modify your relay network fetch implementation to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;queryId&lt;/code&gt; parameter in the
request body instead of a &lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; parameter. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;operation.id&lt;/code&gt; is generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in step 2.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function fetchQuery(operation, variables,) {
  return fetch(‘/graphql’, {
    method: ‘POST’,
    headers: {
      ‘content-type’: ‘application/json’
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response =&amp;gt; {
    return response.json();
  });
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;#step-2-compile&quot;&gt;step 2&lt;/a&gt;, running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcreteBatch&lt;/code&gt; query file and you’ll see that it now has an &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; assigned 
to it and that the query &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; is now &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
const batch /&lt;em&gt;: ConcreteBatch&lt;/em&gt;/ = {
  “fragment”: {
    “argumentDefinitions”: [],
    “kind”: “Fragment”,
    “metadata”: null,
    “name”: “client_index_Query”,
    “selections”: […],
    “type”: “Query”
  },
  “id”: “6082095e8a45f64d38924775d047cf8c”, // look ma, query id!
  “kind”: “Batch”,
  “metadata”: {},
  “name”: “client_index_Query”,
  “query”: {…},
  “text”: null // look again ma, null query text!
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The id is an md5 hash of the query text, generated by the &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js&quot; target=&quot;_blank&quot;&gt;persistQuery&lt;/a&gt; 
function. It looks like this:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
 function persistQuery(operationText: string): Promise&lt;string&gt; {
   return new Promise((resolve) =&amp;gt; {
     const queryId = md5(operationText);&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // queryCache is written to disk at the end as queryMap.json
 queryCache.push({id: queryId, text: operationText});
 resolve(queryId);    });  }    {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
&lt;a href=&quot;#step-3-map-query-ids-on-the-server&quot;&gt;step 3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You can find the package at &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; with a fully working
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me know if this is useful (or not)!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="async" />
<category term="generator" />
<category term="functions" />
<category term="iterator" />
<category term="yield" />
<category term="for-await-of" />
<category term="for" />
<category term="await" />
<category term="of" />
<summary>An exciting new feature of js is async generator functions. A normal function in javascript isrun from beginning till end i.e. run to completion. Once invoked, the entire bodyof the function is executed until the end is reached. You can’t stop or pause the execution of anordinary js function.</summary>
</entry>
<entry>
<title>Relay Modern Server Side Rendering</title>
<link href="http://reactjunkie.com/relay-modern-ssr/" rel="alternate" type="text/html" title="Relay Modern Server Side Rendering" />
<published>2018-01-09T07:30:00+11:00</published>
<updated>2018-01-09T07:30:00+11:00</updated>
<id>http://reactjunkie.com/relay-modern-ssr</id>
<content type="html" xml:base="http://reactjunkie.com/relay-modern-ssr/">&lt;p&gt;Relay modern is awesome, but unfortunately not much has been documented about how to use it with ssr. Facebook
does not use ssr with relay modern so it’s up to the community to do something about it. When I say community it’s
really just one man Jimmy Chia aka taion who has single-handedly written found router, farce and found relay to
make ssr possible with relay modern.&lt;/p&gt;

&lt;p&gt;If you are using react-router, you’re out of luck. You’ll need to jump the cliff and swap it out with found. I have 
done it and I never look back. Found is very similar to react router v3, so you won’t have any problems switching.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Create a relay modern app with ssr with found and found relay.&lt;/p&gt;

&lt;h2 id=&quot;step-1-install-npm-packages&quot;&gt;Step 1: Install npm packages&lt;/h2&gt;
&lt;p&gt;Install babel-polyfill (for async await), found and found relay&lt;/p&gt;

&lt;h2 id=&quot;step-2-create-routes&quot;&gt;Step 2: Create routes&lt;/h2&gt;
&lt;p&gt;create routes, makeRouteConfig, export that routeConfig object.
createBrowserRouter using routeConfig object.&lt;/p&gt;

&lt;h2 id=&quot;step-3-ssr&quot;&gt;Step 3: SSR&lt;/h2&gt;
&lt;p&gt;use the same routes object
on the client bootstrap use createInitialBrowserRouter instead and await on that
u also need createRender function (TODO: investigate why?)&lt;/p&gt;

&lt;p&gt;On the server, await getFarceResult from found/lib/server passing in url, routeConfig and 
render method to get the output data from the requested route.&lt;/p&gt;

&lt;p&gt;Then renderToString the element property from the output. That’s it!&lt;/p&gt;

&lt;p&gt;Without redux, it’s soo much cleaner!&lt;/p&gt;

&lt;p&gt;Install relay-compiler-plus and the latest &lt;a href=&quot;https://github.com/graphql/graphql-js&quot; target=&quot;_blank&quot;&gt;graphql-js&lt;/a&gt; package:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add relay-compiler-plus
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn upgrade graphql –latest
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-compile&quot;&gt;Step 2: Compile&lt;/h2&gt;
&lt;p&gt;Add this npm command to your &lt;strong&gt;package.json&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
“scripts”: {
    “rcp”: “relay-compiler-plus –schema &lt;schema_file_path&gt; --src &lt;src_dir_path&gt; -f&quot;
},
{% endhighlight %}&lt;/src_dir_path&gt;&lt;/schema_file_path&gt;&lt;/p&gt;

&lt;p&gt;where:&lt;br /&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SCHEMA_FILE_PATH&amp;gt;&lt;/code&gt; is the path to your schema.graphql or schema.json file&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SRC_DIR_PATH&amp;gt;&lt;/code&gt; is the path to your src directory&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; will delete all &lt;code class=&quot;highlighter-rouge&quot;&gt;**/__generated__/*.graphql.js&lt;/code&gt; files under &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_DIR_PATH&lt;/code&gt; before compilation starts&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Run the command to start compiling:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
npm run rcp
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-map-query-ids-on-the-server&quot;&gt;Step 3: Map query ids on the server&lt;/h2&gt;
&lt;p&gt;On the server, use &lt;code class=&quot;highlighter-rouge&quot;&gt;matchQueryMiddleware&lt;/code&gt; prior to &lt;code class=&quot;highlighter-rouge&quot;&gt;express-graphql&lt;/code&gt; to match query ids to actual queries. Note 
that &lt;code class=&quot;highlighter-rouge&quot;&gt;queryMap.json&lt;/code&gt; is auto-generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in the previous step.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
import Express from ‘express’;
import expressGraphl from ‘express-graphql’;
import {matchQueryMiddleware} from ‘relay-compiler-plus’; // do this
import queryMapJson from ‘../queryMap.json’; // do this&lt;/p&gt;

&lt;p&gt;const app = Express();&lt;/p&gt;

&lt;p&gt;app.use(‘/graphql’,
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-4-send-query-ids-on-the-client&quot;&gt;Step 4: Send query ids on the client&lt;/h2&gt;
&lt;p&gt;On the client, modify your relay network fetch implementation to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;queryId&lt;/code&gt; parameter in the
request body instead of a &lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; parameter. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;operation.id&lt;/code&gt; is generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in step 2.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function fetchQuery(operation, variables,) {
  return fetch(‘/graphql’, {
    method: ‘POST’,
    headers: {
      ‘content-type’: ‘application/json’
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response =&amp;gt; {
    return response.json();
  });
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;#step-2-compile&quot;&gt;step 2&lt;/a&gt;, running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcreteBatch&lt;/code&gt; query file and you’ll see that it now has an &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; assigned 
to it and that the query &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; is now &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
const batch /&lt;em&gt;: ConcreteBatch&lt;/em&gt;/ = {
  “fragment”: {
    “argumentDefinitions”: [],
    “kind”: “Fragment”,
    “metadata”: null,
    “name”: “client_index_Query”,
    “selections”: […],
    “type”: “Query”
  },
  “id”: “6082095e8a45f64d38924775d047cf8c”, // look ma, query id!
  “kind”: “Batch”,
  “metadata”: {},
  “name”: “client_index_Query”,
  “query”: {…},
  “text”: null // look again ma, null query text!
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The id is an md5 hash of the query text, generated by the &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js&quot; target=&quot;_blank&quot;&gt;persistQuery&lt;/a&gt; 
function. It looks like this:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
 function persistQuery(operationText: string): Promise&lt;string&gt; {
   return new Promise((resolve) =&amp;gt; {
     const queryId = md5(operationText);&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // queryCache is written to disk at the end as queryMap.json
 queryCache.push({id: queryId, text: operationText});
 resolve(queryId);    });  }    {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
&lt;a href=&quot;#step-3-map-query-ids-on-the-server&quot;&gt;step 3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You can find the package at &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; with a fully working
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me know if this is useful (or not)!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="relay" />
<category term="modern" />
<category term="ssr" />
<category term="server" />
<category term="side" />
<category term="rendering" />
<category term="redux" />
<summary>Relay modern is awesome, but unfortunately not much has been documented about how to use it with ssr. Facebookdoes not use ssr with relay modern so it’s up to the community to do something about it. When I say community it’sreally just one man Jimmy Chia aka taion who has single-handedly written found router, farce and found relay tomake ssr possible with relay modern.</summary>
</entry>
<entry>
<title>Relay Modern Persisted Queries</title>
<link href="http://reactjunkie.com/relay-modern-persisted-queries/" rel="alternate" type="text/html" title="Relay Modern Persisted Queries" />
<published>2017-11-12T07:30:00+11:00</published>
<updated>2017-11-12T07:30:00+11:00</updated>
<id>http://reactjunkie.com/relay-modern-persisted-queries</id>
<content type="html" xml:base="http://reactjunkie.com/relay-modern-persisted-queries/">&lt;p&gt;This blog is about &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;relay-compiler-plus&lt;/a&gt;, 
a custom relay compiler which supports persisted queries.&lt;/p&gt;

&lt;p&gt;One of the more exciting features of relay modern is the ability to use persisted queries with the graphql server.
Instead of sending the full graphql query in the request payload, you send a short query id which gets mapped
on the server side to the full query. It’s a no-brainer for performance. I upgraded from classic for this!&lt;/p&gt;

&lt;p&gt;Alas, the official &lt;a href=&quot;https://facebook.github.io/relay/docs/new-in-relay-modern.html&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt;
only briefly mentioned this without anything else. A quick google search reveals a solution from 
&lt;a href=&quot;https://medium.com/@wonderboymusic/upgrading-to-relay-modern-or-apollo-ffa58d3a5d59&quot; target=&quot;_blank&quot;&gt;Scott Taylor&lt;/a&gt;
from the New York Times. However his solution generates query ids at runtime at the network fetch level which is not
optimal. I want a solution where the query ids and the query map file are both generated at compile time for maximum
performance.&lt;/p&gt;

&lt;p&gt;It turns out, the original relay-compiler does have a hidden feature to support persisted queries.&lt;/p&gt;

&lt;p&gt;This package is inspired by a conversation with &lt;a href=&quot;https://github.com/leebyron&quot; target=&quot;_blank&quot;&gt;Lee Byron&lt;/a&gt; 
at &lt;a href=&quot;https://summit.graphql.com/&quot; target=&quot;_blank&quot;&gt;Graphql Summit 2017&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-key&quot;&gt;The key&lt;/h2&gt;
&lt;p&gt;The key lies in &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/codegen/RelayFileWriter.js&quot; target=&quot;_blank&quot;&gt;RelayFileWriter&lt;/a&gt;.
It accepts a config object where you can specify a &lt;code class=&quot;highlighter-rouge&quot;&gt;persistQuery&lt;/code&gt; function. You can dig around and peruse
that code at your leisure (which I did). The end result is a modification to the relay-compiler which
accepts a &lt;code class=&quot;highlighter-rouge&quot;&gt;persistQuery&lt;/code&gt; function which gets passed down to &lt;code class=&quot;highlighter-rouge&quot;&gt;RelayFileWriter&lt;/code&gt;. I call it 
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;relay-compiler-plus&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;step-1-install&quot;&gt;Step 1: Install&lt;/h2&gt;
&lt;p&gt;Install relay-compiler-plus and the latest &lt;a href=&quot;https://github.com/graphql/graphql-js&quot; target=&quot;_blank&quot;&gt;graphql-js&lt;/a&gt; package:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn add relay-compiler-plus
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn upgrade graphql –latest
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-compile&quot;&gt;Step 2: Compile&lt;/h2&gt;
&lt;p&gt;Add this npm command to your &lt;strong&gt;package.json&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight json %}
“scripts”: {
    “rcp”: “relay-compiler-plus –schema &lt;schema_file_path&gt; --src &lt;src_dir_path&gt; -f&quot;
},
{% endhighlight %}&lt;/src_dir_path&gt;&lt;/schema_file_path&gt;&lt;/p&gt;

&lt;p&gt;where:&lt;br /&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SCHEMA_FILE_PATH&amp;gt;&lt;/code&gt; is the path to your schema.graphql or schema.json file&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;SRC_DIR_PATH&amp;gt;&lt;/code&gt; is the path to your src directory&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; will delete all &lt;code class=&quot;highlighter-rouge&quot;&gt;**/__generated__/*.graphql.js&lt;/code&gt; files under &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_DIR_PATH&lt;/code&gt; before compilation starts&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Run the command to start compiling:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
npm run rcp
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-map-query-ids-on-the-server&quot;&gt;Step 3: Map query ids on the server&lt;/h2&gt;
&lt;p&gt;On the server, use &lt;code class=&quot;highlighter-rouge&quot;&gt;matchQueryMiddleware&lt;/code&gt; prior to &lt;code class=&quot;highlighter-rouge&quot;&gt;express-graphql&lt;/code&gt; to match query ids to actual queries. Note 
that &lt;code class=&quot;highlighter-rouge&quot;&gt;queryMap.json&lt;/code&gt; is auto-generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in the previous step.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
import Express from ‘express’;
import expressGraphl from ‘express-graphql’;
import {matchQueryMiddleware} from ‘relay-compiler-plus’; // do this
import queryMapJson from ‘../queryMap.json’; // do this&lt;/p&gt;

&lt;p&gt;const app = Express();&lt;/p&gt;

&lt;p&gt;app.use(‘/graphql’,
  matchQueryMiddleware(queryMapJson), // do this
  expressGraphl({
    schema: graphqlSchema,
    graphiql: true,
  }));
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-4-send-query-ids-on-the-client&quot;&gt;Step 4: Send query ids on the client&lt;/h2&gt;
&lt;p&gt;On the client, modify your relay network fetch implementation to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;queryId&lt;/code&gt; parameter in the
request body instead of a &lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; parameter. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;operation.id&lt;/code&gt; is generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;relay-compiler-plus&lt;/code&gt; in step 2.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
function fetchQuery(operation, variables,) {
  return fetch(‘/graphql’, {
    method: ‘POST’,
    headers: {
      ‘content-type’: ‘application/json’
    },
    body: JSON.stringify({
      queryId: operation.id, // do this
      variables,
    }),
  }).then(response =&amp;gt; {
    return response.json();
  });
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;bonus&quot;&gt;Bonus&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;#step-2-compile&quot;&gt;step 2&lt;/a&gt;, running relay-compiler-plus generates relay query files like the original relay-compiler,
but with a difference. Inspect a generated &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcreteBatch&lt;/code&gt; query file and you’ll see that it now has an &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; assigned 
to it and that the query &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; is now &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
const batch /&lt;em&gt;: ConcreteBatch&lt;/em&gt;/ = {
  “fragment”: {
    “argumentDefinitions”: [],
    “kind”: “Fragment”,
    “metadata”: null,
    “name”: “client_index_Query”,
    “selections”: […],
    “type”: “Query”
  },
  “id”: “6082095e8a45f64d38924775d047cf8c”, // look ma, query id!
  “kind”: “Batch”,
  “metadata”: {},
  “name”: “client_index_Query”,
  “query”: {…},
  “text”: null // look again ma, null query text!
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The id is an md5 hash of the query text, generated by the &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/blob/master/src/compiler/main.js&quot; target=&quot;_blank&quot;&gt;persistQuery&lt;/a&gt; 
function. It looks like this:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
 function persistQuery(operationText: string): Promise&lt;string&gt; {
   return new Promise((resolve) =&amp;gt; {
     const queryId = md5(operationText);&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // queryCache is written to disk at the end as queryMap.json
 queryCache.push({id: queryId, text: operationText});
 resolve(queryId);    });  }    {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see above, the hash to query text mapping is saved to an array which gets written to disk
at the end of the compilation as queryMap.json. This is used on the server side as outlined in 
&lt;a href=&quot;#step-3-map-query-ids-on-the-server&quot;&gt;step 3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You can find the package at &lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; with a fully working
&lt;a href=&quot;https://github.com/yusinto/relay-compiler-plus/tree/master/example&quot; target=&quot;_blank&quot;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me know if this is useful (or not)!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="relay" />
<category term="modern" />
<category term="persisted" />
<category term="queries" />
<category term="graphql" />
<category term="javascript" />
<category term="js" />
<summary>This blog is about relay-compiler-plus, a custom relay compiler which supports persisted queries.</summary>
</entry>
<entry>
<title>Javascript Job Queues and Promises</title>
<link href="http://reactjunkie.com/promises-promises/" rel="alternate" type="text/html" title="Javascript Job Queues and Promises" />
<published>2017-09-18T07:30:00+10:00</published>
<updated>2017-09-18T07:30:00+10:00</updated>
<id>http://reactjunkie.com/promises-promises</id>
<content type="html" xml:base="http://reactjunkie.com/promises-promises/">&lt;p&gt;So you think you know how promises work? Someone ever comes to you
with a little trivia called “what’s the sequence of console logs from this
piece of async code”? And no matter how hard you try you never get
it right?&lt;/p&gt;

&lt;p&gt;I experienced this at work last week and in process learnt something new about
promises which I would like to share.&lt;/p&gt;

&lt;p&gt;There are few (if any) that explain the scheduling aspects of Promises though.
Perhaps because it’s not a hot topic. It’s too low level. You need a
shot of vodka to understand it. Bla bla.. so here goes nothing.&lt;/p&gt;

&lt;p&gt;This is not an intro to promises or how to use them. There are plenty
of blogs out there explaining that in complete pornographic detail (give me
that vodka!). No sir, today I’ll be talking about the temporal aspects
of promises i.e. “when” your code gets executed and why.&lt;/p&gt;

&lt;p&gt;It’s actually very interesting!&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Understand when parts of your promise gets executed and why.&lt;/p&gt;

&lt;h2 id=&quot;step-1-anatomy-of-a-promise&quot;&gt;Step 1: Anatomy of a Promise&lt;/h2&gt;
&lt;p&gt;{% highlight javascript %}
const p = new Promise(
    // this function is called the “executor”
    (resolve, reject) =&amp;gt; {
        console.log(1);
        resolve(2);
        console.log(3);
    }
);&lt;/p&gt;

&lt;p&gt;console.log(4);&lt;/p&gt;

&lt;p&gt;p.then(
    // this is the success handler
    result =&amp;gt; console.log(result)
);&lt;/p&gt;

&lt;p&gt;console.log(5);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;What is the output of the code above? We’ll go through this in this blog.&lt;/p&gt;

&lt;h2 id=&quot;step-2-the-event-loop&quot;&gt;Step 2: The event loop&lt;/h2&gt;
&lt;p&gt;This gives javascript that infamous single-threaded reputation. It is
an infinite while true loop that continues forever. Each iteration of
this loop is called a “tick”.&lt;/p&gt;

&lt;h2 id=&quot;step-2-the-queue&quot;&gt;Step 2: The Queue&lt;/h2&gt;
&lt;p&gt;Each tick processes an item off the queue.&lt;/p&gt;

&lt;h2 id=&quot;step-3-the-job-queue&quot;&gt;Step 3. The Job Queue&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Download &lt;a href=&quot;https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz&quot;&gt;emscripten portable&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Unzip and cd into the dir and execute these:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% highlight bash %}
./emsdk update
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
{% endhighlight %}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Add the emcc executable to your /etc/paths file. Mine is
located at /your_download_dir/emsdk-portable/emscripten/1.37.16&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;step-2-write-c-code&quot;&gt;Step 2: Write C code&lt;/h2&gt;
&lt;p&gt;Create a file called utils.c under your src folder.&lt;/p&gt;

&lt;h4 id=&quot;utilsc&quot;&gt;utils.c&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &amp;lt;emscripten/emscripten.h&amp;gt;&lt;/time.h&gt;&lt;/stdlib.h&gt;&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;int main(int argc, char ** argv) {
    // gets translated to console.log
    printf(“WebAssembly successfully loaded!\n”);
}&lt;/p&gt;

&lt;p&gt;// Emscripten does dead code elimination during compilation.
// This decorator ensures our code does not get removed.
EMSCRIPTEN_KEEPALIVE
int generateRandom() {
    srand ( time(NULL) );
    return rand();
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-compile-your-c-code&quot;&gt;Step 3: Compile your C code&lt;/h2&gt;

&lt;p&gt;{% highlight bash %}
emcc utils.c -s WASM=1 -o utils.js -O3
{% endhighlight %}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;-s Specify settings which gets passed down to the emscripten compiler. Here
we specify we want to compile to wasm. The default is asm. This will
produce utils.wasm.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-o Specify the filename for the glue code. This will produce utils.js.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-O3 The first character is the upper case letter ‘O’ not zero! Sets the optimisation
level for your wasm and js files. You can check the various optimisation levels
&lt;a href=&quot;https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html#emcc-o0&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;step-4-add-the-glue-code-to-your-html&quot;&gt;Step 4: Add the glue code to your html&lt;/h2&gt;

&lt;p&gt;{% highlight html %}
&amp;lt;!DOCTYPE html&amp;gt;
    &amp;lt;html&amp;gt;
         &amp;lt;head&amp;gt;
            &lt;title&gt;Hasta la vista JS!&lt;/title&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
          &amp;lt;/head&amp;gt;
          &amp;lt;body&amp;gt;
            &amp;lt;div id=&quot;reactDiv&quot;/&amp;gt;
            &lt;script src=&quot;/dist/utils.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
          &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-5-add-an-express-route-to-serve-wasm-files&quot;&gt;Step 5: Add an express route to serve wasm files&lt;/h2&gt;

&lt;p&gt;Express does not serve .wasm files by default so we have to add a custom route.&lt;/p&gt;

&lt;h4 id=&quot;serverjs&quot;&gt;server.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
app.get(‘/:filename.wasm’, (req, res) =&amp;gt; {
  const wasmFilePath = path.resolve(__dirname, 
    &lt;code class=&quot;highlighter-rouge&quot;&gt;../../dist/${req.params.filename}.wasm&lt;/code&gt;);&lt;/p&gt;

&lt;p&gt;console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Wasm request ${wasmFilePath}&lt;/code&gt;);&lt;/p&gt;

&lt;p&gt;fs.readFile(wasmFilePath, (err, data) =&amp;gt; {
    const errorMessage = &lt;code class=&quot;highlighter-rouge&quot;&gt;Error ${wasmFilePath} not found. ${JSON.stringify(err)}&lt;/code&gt;;
    if (err) {
      console.log(errorMessage);
      res.status(404).send(errorMessage);
      return;
    }
    res.send(data);
  });
});
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-6-call-wasm-from-react&quot;&gt;Step 6: Call wasm from React!&lt;/h2&gt;

&lt;p&gt;Finally! You can now use your C function from React by prefixing an underscore
in front of the C function’s name. We included the glue code in our app html, so
all your C methods are exposed globally. This is not the best way, but 
in the future, webpack will rescue us. There is &lt;a href=&quot;https://medium.com/webpack/webpack-awarded-125-000-from-moss-program-f63eeaaf4e15&quot; target=&quot;_blank&quot;&gt;wip&lt;/a&gt;
right now sponsored by Mozilla to develop first class support for WebAssembly in webpack. 
This means we’ll be able to import C/C++ files directly in js files and
call wasm functions directly!&lt;/p&gt;

&lt;p&gt;Till that day arrives, a global script tag will have to do for now.&lt;/p&gt;

&lt;h4 id=&quot;appjs&quot;&gt;app.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;export default class App extends Component {
    state = {randomNumber: -1};&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;onClickGenerateRandom = () =&amp;gt; {
  // EUREKA! Call our C function with an underscore prefix!
  // All the methods in utils.c are exposed globally because utils.js
  // is included as a script tag in our html.
  const randomNumber = _generateRandom();
  console.log(`onClickGenerateRandom: ${randomNumber}`);
  this.setState({randomNumber});
}; 
  
render() {
  return (
    &amp;lt;div&amp;gt;
      &amp;lt;button onClick={this.onClickGenerateRandom}&amp;gt;
        Generate random
      &amp;lt;/button&amp;gt;
      {this.state.randomNumber}
    &amp;lt;/div&amp;gt;
  );
} } {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The next step is to help Sean Larkin and co to get webpack support WebAssembly!&lt;/p&gt;

&lt;p&gt;The complete code is &lt;a href=&quot;https://github.com/yusinto/wasm-playground&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;
as usual. Start learning C/C++. Enjoy!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="javascript" />
<category term="promises" />
<category term="job" />
<category term="queues" />
<category term="js" />
<category term="asynchronous" />
<summary>So you think you know how promises work? Someone ever comes to youwith a little trivia called “what’s the sequence of console logs from thispiece of async code”? And no matter how hard you try you never getit right?</summary>
</entry>
<entry>
<title>WebAssembly and React</title>
<link href="http://reactjunkie.com/webassembly-react/" rel="alternate" type="text/html" title="WebAssembly and React" />
<published>2017-08-04T07:30:00+10:00</published>
<updated>2017-08-04T07:30:00+10:00</updated>
<id>http://reactjunkie.com/webassembly-react</id>
<content type="html" xml:base="http://reactjunkie.com/webassembly-react/">&lt;p&gt;WebAssembly is the next big thing. So they say. Who knows. All I know is
that it’s fast and it can make my app goes faster, like native fast. So
naturally I am interested.&lt;/p&gt;

&lt;p&gt;I looked around for a quick guide to get WebAssembly up and running in
node, express and react but couldn’t find one. So I decided to do it myself.&lt;/p&gt;

&lt;p&gt;Let’s begin!&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;Run a C function from a .wasm file in a react component.&lt;/p&gt;

&lt;h2 id=&quot;step-1-install-emscripten&quot;&gt;Step 1: Install emscripten&lt;/h2&gt;
&lt;p&gt;Emscripten compiles C/C++ code to web assembly. Given a C file,
emscripten produces a .wasm and a .js file.&lt;/p&gt;

&lt;p&gt;.wasm is a binary file. You can’t easily
import .wasm files directly into js (&lt;a href=&quot;https://medium.com/webpack/webpack-awarded-125-000-from-moss-program-f63eeaaf4e15&quot; target=&quot;_blank&quot;&gt;yet!&lt;/a&gt;) so 
emscripten also produces a js file which acts as a proxy. You add a 
script reference to this file in your html so you can use wasm in your 
js app. They call this js file the “glue” code. Personally I prefer to call
it proxy code.&lt;/p&gt;

&lt;p&gt;Here are the steps to install emscripten:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Download &lt;a href=&quot;https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz&quot;&gt;emscripten portable&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Unzip and cd into the dir and execute these:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% highlight bash %}
./emsdk update
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
{% endhighlight %}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Add the emcc executable to your /etc/paths file. Mine is
located at /your_download_dir/emsdk-portable/emscripten/1.37.16&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;step-2-write-c-code&quot;&gt;Step 2: Write C code&lt;/h2&gt;
&lt;p&gt;Create a file called utils.c under your src folder.&lt;/p&gt;

&lt;h4 id=&quot;utilsc&quot;&gt;utils.c&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &amp;lt;emscripten/emscripten.h&amp;gt;&lt;/time.h&gt;&lt;/stdlib.h&gt;&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;int main(int argc, char ** argv) {
    // gets translated to console.log
    printf(“WebAssembly successfully loaded!\n”);
}&lt;/p&gt;

&lt;p&gt;// Emscripten does dead code elimination during compilation.
// This decorator ensures our code does not get removed.
EMSCRIPTEN_KEEPALIVE
int generateRandom() {
    srand ( time(NULL) );
    return rand();
}
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-3-compile-your-c-code&quot;&gt;Step 3: Compile your C code&lt;/h2&gt;

&lt;p&gt;{% highlight bash %}
emcc utils.c -s WASM=1 -o utils.js -O3
{% endhighlight %}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;-s Specify settings which gets passed down to the emscripten compiler. Here
we specify we want to compile to wasm. The default is asm. This will
produce utils.wasm.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-o Specify the filename for the glue code. This will produce utils.js.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-O3 The first character is the upper case letter ‘O’ not zero! Sets the optimisation
level for your wasm and js files. You can check the various optimisation levels
&lt;a href=&quot;https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html#emcc-o0&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;step-4-add-the-glue-code-to-your-html&quot;&gt;Step 4: Add the glue code to your html&lt;/h2&gt;

&lt;p&gt;{% highlight html %}
&amp;lt;!DOCTYPE html&amp;gt;
    &amp;lt;html&amp;gt;
         &amp;lt;head&amp;gt;
            &lt;title&gt;Hasta la vista JS!&lt;/title&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
          &amp;lt;/head&amp;gt;
          &amp;lt;body&amp;gt;
            &amp;lt;div id=&quot;reactDiv&quot;/&amp;gt;
            &lt;script src=&quot;/dist/utils.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
          &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-5-add-an-express-route-to-serve-wasm-files&quot;&gt;Step 5: Add an express route to serve wasm files&lt;/h2&gt;

&lt;p&gt;Express does not serve .wasm files by default so we have to add a custom route.&lt;/p&gt;

&lt;h4 id=&quot;serverjs&quot;&gt;server.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
app.get(‘/:filename.wasm’, (req, res) =&amp;gt; {
  const wasmFilePath = path.resolve(__dirname, 
    &lt;code class=&quot;highlighter-rouge&quot;&gt;../../dist/${req.params.filename}.wasm&lt;/code&gt;);&lt;/p&gt;

&lt;p&gt;console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Wasm request ${wasmFilePath}&lt;/code&gt;);&lt;/p&gt;

&lt;p&gt;fs.readFile(wasmFilePath, (err, data) =&amp;gt; {
    const errorMessage = &lt;code class=&quot;highlighter-rouge&quot;&gt;Error ${wasmFilePath} not found. ${JSON.stringify(err)}&lt;/code&gt;;
    if (err) {
      console.log(errorMessage);
      res.status(404).send(errorMessage);
      return;
    }
    res.send(data);
  });
});
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-6-call-wasm-from-react&quot;&gt;Step 6: Call wasm from React!&lt;/h2&gt;

&lt;p&gt;Finally! You can now use your C function from React by prefixing an underscore
in front of the C function’s name. We included the glue code in our app html, so
all your C methods are exposed globally. This is not the best way, but 
in the future, webpack will rescue us. There is &lt;a href=&quot;https://medium.com/webpack/webpack-awarded-125-000-from-moss-program-f63eeaaf4e15&quot; target=&quot;_blank&quot;&gt;wip&lt;/a&gt;
right now sponsored by Mozilla to develop first class support for WebAssembly in webpack. 
This means we’ll be able to import C/C++ files directly in js files and
call wasm functions directly!&lt;/p&gt;

&lt;p&gt;Till that day arrives, a global script tag will have to do for now.&lt;/p&gt;

&lt;h4 id=&quot;appjs&quot;&gt;app.js&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;export default class App extends Component {
    state = {randomNumber: -1};&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;onClickGenerateRandom = () =&amp;gt; {
  // EUREKA! Call our C function with an underscore prefix!
  // All the methods in utils.c are exposed globally because utils.js
  // is included as a script tag in our html.
  const randomNumber = _generateRandom();
  console.log(`onClickGenerateRandom: ${randomNumber}`);
  this.setState({randomNumber});
}; 
  
render() {
  return (
    &amp;lt;div&amp;gt;
      &amp;lt;button onClick={this.onClickGenerateRandom}&amp;gt;
        Generate random
      &amp;lt;/button&amp;gt;
      {this.state.randomNumber}
    &amp;lt;/div&amp;gt;
  );
} } {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The next step is to help Sean Larkin and co to get webpack support WebAssembly!&lt;/p&gt;

&lt;p&gt;The complete code is &lt;a href=&quot;https://github.com/yusinto/wasm-playground&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;
as usual. Start learning C/C++. Enjoy!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="webAssembly" />
<category term="react" />
<category term="wasm" />
<category term="web" />
<category term="assembly" />
<category term="javascript" />
<category term="c" />
<category term="c++" />
<category term="emscripten" />
<summary>WebAssembly is the next big thing. So they say. Who knows. All I know isthat it’s fast and it can make my app goes faster, like native fast. Sonaturally I am interested.</summary>
</entry>
<entry>
<title>Writing Graphcool functions in es6 with async await and jest</title>
<link href="http://reactjunkie.com/graphcool-functions-in-es6-with-async-await/" rel="alternate" type="text/html" title="Writing Graphcool functions in es6 with async await and jest" />
<published>2017-06-30T08:30:00+10:00</published>
<updated>2017-06-30T08:30:00+10:00</updated>
<id>http://reactjunkie.com/graphcool-functions-in-es6-with-async-await</id>
<content type="html" xml:base="http://reactjunkie.com/graphcool-functions-in-es6-with-async-await/">&lt;p&gt;Graphcool is cool. Graphcool functions are even cooler. There are two types of functions:
request pipeline and server side subscription. Request pipeline function gets triggered
at a specified stage of a crud request. You write custom business logic you want to execute
as part of your api requests here. It is synchronous.&lt;/p&gt;

&lt;p&gt;The second type of function is server side subscription. These get triggered
&lt;b&gt;after&lt;/b&gt; crud operations. Your write custom business logic here to
react to crud events in your database. Server side subscriptions are
asynchronous.&lt;/p&gt;

&lt;p&gt;In this blog, I will talk about server side subscriptions. A crud occurs
on the server and we want to execute some business logic after that happens.
The traditional solution is to do it in our own backend in node/java/.net
probably in the business logic layer. But that means we need to host our
own backend server which means we have to worry about infrastructure.
Can we do better?&lt;/p&gt;

&lt;p&gt;Yes we can. Enter Graphcool server side subscriptions. You write your business logic directly in
the Graphcool console and specify the event which will trigger this logic.&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;The goal is to create a stripe customer when a Graphcool customer is created. It’s a very common
use case. The complete code is &lt;a href=&quot;https://github.com/yusinto/functions/tree/master/stripe-create-customer-es6&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Enough talk, let’s code!&lt;/p&gt;

&lt;h2 id=&quot;step-1-create-graphcool-schema&quot;&gt;Step 1: Create Graphcool schema&lt;/h2&gt;
&lt;p&gt;Create a Customer type in your Graphcool backend so we have something to crud with.&lt;/p&gt;

&lt;h4 id=&quot;customergraphql&quot;&gt;customer.graphql&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
type Customer implements Node {
  email: String!
  stripeCustomerId: String
  id: ID! @isUnique
  createdAt: DateTime!
  updatedAt: DateTime!
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Use the graphcool cli to create a new Graphcool project and create the Customer type.&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
npm -g install graphcool
graphcool init –schema customer.graphql
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;step-2-create-graphcool-server-side-subscription&quot;&gt;Step 2: Create Graphcool server side subscription&lt;/h2&gt;
&lt;p&gt;The cli is powerful but it is still work in progress. You can’t create functions
via the cli at this stage (yet). We’ll create our ssr function via the console
for now. You can open the console using the cli:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
graphcool console
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Go to functions -&amp;gt; new function -&amp;gt; server-side subscription -&amp;gt; select Customer type
as the trigger and click define function. Copy paste the subscription query
below into the left window pane under subscription query.&lt;/p&gt;

&lt;h4 id=&quot;subscriptiongraphql&quot;&gt;subscription.graphql&lt;/h4&gt;
&lt;p&gt;{% highlight C# %}
subscription {
  Customer(filter: {
    mutation_in: [CREATED]
  }) {
    updatedFields
    node {
      id
      email
    }
  }
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Let’s look at this in detail:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
The &lt;b&gt;&lt;i&gt;subscription&lt;/i&gt;&lt;/b&gt; keyword is a third operation recently added to
graphql in addition to query and mutation.
&lt;/li&gt;
&lt;li&gt;The subscription above means we are subscribing only to Customer create events.
You can also listen to UPDATED and DELETED events but we don&#39;t need those here.
&lt;/li&gt;
&lt;li&gt;When a Customer is created, return the id and email of that newly created customer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Back in the console click “Create Function”. Leave inline code on the right pane
as is for now, we’ll write the code for this in the next section.&lt;/p&gt;

&lt;h2 id=&quot;step-3-write-code&quot;&gt;Step 3: Write code!&lt;/h2&gt;
&lt;p&gt;Finally we get to write some code! You can code directly
in the console inline editor, but doing so forgoes a lot of the benefit
of your IDE. Furthermore, behind the scenes inline functions are deployed
to &lt;a href=&quot;https://webtask.io/&quot;&gt;webtask&lt;/a&gt; which is cool
but does not support async await.&lt;/p&gt;

&lt;p&gt;Optionally you can also write and host your code elsewhere (like aws lambda) and
specify that as a webhook. But this means you have to worry about hosting
your code elsewhere.&lt;/p&gt;

&lt;p&gt;In this blog, we want to be able to write es6 code with async await, linting, unit tests,
strong typing, etc in the comfort of our favourite IDE and be able to
deploy that to graphcool. To do this we have to bite the bullet and use
webpack to transpile our code. Luckily for you fellow js devs, readers and
oss fans, I’ve done all the hard work! I have worked out the minimal webpack
config to support async await and the latest es6 features to write Graphcool
functions. There’s a &lt;a href=&quot;#bonus-webpack-configuration&quot;&gt;bonus section&lt;/a&gt; at the
end of this blog if you are interested in how the webpack config works.&lt;/p&gt;

&lt;h3 id=&quot;step-31-copy-packagejson&quot;&gt;Step 3.1: Copy package.json&lt;/h3&gt;
&lt;p&gt;Copy package.json from &lt;a href=&quot;https://github.com/yusinto/functions/tree/master/stripe-create-customer-es6&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;
to your root directory. Then do yarn.&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
yarn
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The devDependencies are mostly used by webpack to transpile our code. We also
use jest for unit tests so that’s in there too. We also need the stripe
library and a fetch library so those are included as dependencies.&lt;/p&gt;

&lt;h3 id=&quot;step-32-copy-webpackconfigjs-and-babelrc-and-create-src-dir&quot;&gt;Step 3.2: Copy webpack.config.js and .babelrc and create src dir&lt;/h3&gt;
&lt;p&gt;Copy webpack.config.js and .babelrc files from &lt;a href=&quot;https://github.com/yusinto/functions/tree/master/stripe-create-customer-es6&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;
into the root directory of your project. Check the
&lt;a href=&quot;#bonus-webpack-configuration&quot;&gt;bonus section&lt;/a&gt; below if you want to dig
into the webpack config.&lt;/p&gt;

&lt;p&gt;Also at the root of your project, create a src directory where all your code lives.&lt;/p&gt;

&lt;h2 id=&quot;step-33&quot;&gt;Step 3.3:&lt;/h2&gt;
&lt;p&gt;Create a file called src/createStripeCustomer.js. This file contains all
of our function code. Note that the webpack config you copied is hardcoded to
look for this file under src/createStripeCustomer.js. You can change this
in webpack.config.js if you wish.&lt;/p&gt;

&lt;h4 id=&quot;main-method&quot;&gt;main method&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
const main = event =&amp;gt; {
  const {id, email} = event.data.Customer.node;&lt;/p&gt;

&lt;p&gt;return new Promise(async (resolve, reject) =&amp;gt; {
    try {
      const stripeCustomer = await createStripeCustomer(email);
      const graphCoolCustomer = await updateGraphCoolCustomer(id, stripeCustomer.id);
      console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Successfully updated GraphCool customer: ${JSON.stringify(graphCoolCustomer)}&lt;/code&gt;);
      resolve(event);
    }
    catch (err) {
      console.log(err);
      reject(err);
    }
  });
};
{% endhighlight %}&lt;/p&gt;

&lt;h4 id=&quot;createstripecustomer-method&quot;&gt;createStripeCustomer method&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
const createStripeCustomer = async email =&amp;gt; {
  console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Creating stripe customer for ${email}&lt;/code&gt;);
  let stripeCustomer;&lt;/p&gt;

&lt;p&gt;try {
    stripeCustomer = await stripe.customers.create({email});
    console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Successfully created Stripe customer: ${stripeCustomer.id}&lt;/code&gt;);
    return stripeCustomer;
  }
  catch (err) {
    console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Error creating Stripe customer: ${JSON.stringify(err)}&lt;/code&gt;);
    throw err;
  }
};
{% endhighlight %}&lt;/p&gt;

&lt;h4 id=&quot;updategraphcoolcustomer-method&quot;&gt;updateGraphCoolCustomer method&lt;/h4&gt;
&lt;p&gt;{% highlight javascript %}
const updateGraphCoolCustomer = async (id, stripeCustomerId) =&amp;gt; {
  const updateCustomer = JSON.stringify({
    query: `
        mutation {
          updateCustomer(
            id: “${id}”,
            stripeCustomerId: “${stripeCustomerId}”,
          ) {
            id
            stripeCustomerId
            email
          }
        }
      `
  });&lt;/p&gt;

&lt;p&gt;try {
    const response = await fetch(graphCoolEndpoint, {
      headers: {‘content-type’: ‘application/json’},
      method: ‘POST’,
      body: updateCustomer,
    });
    return await response.json();
  }
  catch (err) {
    console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Error updating GraphCool customer: ${JSON.stringify(err)}&lt;/code&gt;);
    throw err;
  }
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The entire file is available &lt;a href=&quot;https://github.com/graphcool-examples/functions/blob/master/stripe-create-customer-es6/src/createStripeCustomer.js&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;
on github.&lt;/p&gt;

&lt;h2 id=&quot;step-4-deploy-and-test&quot;&gt;Step 4: Deploy and test&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&quot;bonus-webpack-configuration&quot;&gt;Bonus: webpack configuration&lt;/h2&gt;
&lt;p&gt;This is not a webpack tutorial but I want to share a few interesting things I
discovered while working on this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
We will export our function by setting module.exports so we need to set
output.libraryTarget to commonjs2.
&lt;/li&gt;
&lt;li&gt;
&lt;b&gt;DO NOT BUNDLE THIRD PARTY LIBRARIES!&lt;/b&gt; This will blow up your code size, and it&#39;s
not necessary. Your Graphcool function is executed in webtask
and it supports most of the npm packages you&#39;ll need. Check [here](https://tehsis.github.io/webtaskio-canirequire/){:target=&quot;_blank&quot;}
for packages webtask supports.
&lt;/li&gt;
&lt;li&gt;As a result of the point above, use
[webpack-node-externals](https://github.com/liady/webpack-node-externals){:target=&quot;_blank&quot;} to exclude all npm packages.
&lt;/li&gt;
&lt;li&gt;
GOTCHA: To enable latest es6 features and async await, we have to include two npm packages: babel-polyfill and regenerator-runtime/runtime
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you are interested, you can check the complete webpack config &lt;a href=&quot;https://github.com/graphcool-examples/functions/blob/master/stripe-create-customer-es6/webpack.config.js&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;With client side subscriptions, you’ll use apollo with
the &lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot; target=&quot;_blank&quot;&gt;subscriptions-transport-ws&lt;/a&gt;
to enable your js client app to “hot listen” to server changes. The server pushes notifications
to the client, which reacts to these notifications in real-time. It’s super cool!&lt;/p&gt;

&lt;p&gt;This approach incurs a little more time to setup, but I think it’s worth it. We leave the code fully testable, encapsulation intact. 
This feels right for me. Also, you can apply the same technique to test react components wrapped in relay containers. It works!&lt;/p&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://github.com/yusinto/test-react&quot; target=&quot;_blank&quot;&gt;sample code&lt;/a&gt; for a working example and let me know if this is useful (or not)!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="graphcool" />
<category term="functions" />
<category term="server" />
<category term="side" />
<category term="subscription" />
<category term="async" />
<category term="await" />
<category term="es6" />
<category term="graphql" />
<category term="jest" />
<summary>Graphcool is cool. Graphcool functions are even cooler. There are two types of functions:request pipeline and server side subscription. Request pipeline function gets triggeredat a specified stage of a crud request. You write custom business logic you want to executeas part of your api requests here. It is synchronous.</summary>
</entry>
<entry>
<title>React Europe</title>
<link href="http://reactjunkie.com/react-europe/" rel="alternate" type="text/html" title="React Europe" />
<published>2017-05-20T09:30:00+10:00</published>
<updated>2017-05-20T09:30:00+10:00</updated>
<id>http://reactjunkie.com/react-europe</id>
<content type="html" xml:base="http://reactjunkie.com/react-europe/">&lt;p&gt;As I stared at the partially cloudy Parisian sky from my seat at Gare du Nord, 
I had a chance to reflect on the week that was. 4 days jam packed with 
javascript and react from morning till night followed by socialising afterwards 
(my fave), it’s definitely not for the faint-hearted. I admit I was a little 
overwhelmed by the intensity of the schedule.&lt;/p&gt;

&lt;h2 id=&quot;workshops&quot;&gt;Workshops&lt;/h2&gt;
&lt;p&gt;I attended a 2-day advanced react workshop with &lt;a href=&quot;https://github.com/nikgraf&quot; target=&quot;_blank&quot;&gt;Nik Graf (serverless)&lt;/a&gt;
and &lt;a href=&quot;https://github.com/mxstbr&quot; target=&quot;_blank&quot;&gt;Max Stoiber (styled components)&lt;/a&gt;. 
I learnt loads about the react children api which I never really used before from Max and about
the apollo graphql client for react from both Nik and Max. The exercises were very hands-on and realistic.
In one exercise we had to implement a graphql backend and apollo front end for a recipe application.
This involves setting up the graphql types, queries and mutations.&lt;/p&gt;

&lt;p&gt;I am already using graphql and relay at work (qantasassure.com) so I thought this would be a piece of cake.
Not exactly. It turns out the tools for graphql in the backend and frontend have
evolved so much since I set it up 6 months ago, it was almost foreign to me. In a good way.
I learnt it’s so much easier and simpler now to setup a graphql server with types and queries and mutations.
Apollo really has done a lot of work to simplify the integration of graphql into react.&lt;/p&gt;

&lt;p&gt;It’s so good to finally see the face behind the code! I am both a fan and user of serverless
and styled components, so thanks for teaching me so much guys!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/max_nik.png&quot; alt=&quot;Max Stoiber and Nik Graf&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-main-event&quot;&gt;The main event&lt;/h2&gt;
&lt;p&gt;Prior to the start of the conference we heard word that Dan Abramov will not make it to Paris.
He had some visa issues which didn’t allow him to enter Paris. Fuck. I should really ask for
a refund.&lt;/p&gt;

&lt;p&gt;Anyway the conference started with Andrew Clark (recompose) announcing the imminent release
of react fiber (eta end of year). He’s one of the better speakers in the conference. I tend to
pay more attention to people who use the stage and are comfortable moving about on the stage.
The delivery style of the presentation is also important. Some speakers tend to just read off
the screen and narrate, just the recipe to put people to sleep. Think kids and bedtime 
story time. I expected more from all the speakers in this regard.&lt;/p&gt;

&lt;p&gt;Andrew and a few others like Lee Byron, Kevin Lacker, Sunil Pai were excellent though. Part improvised 
part narratted, I really enjoy their presentations. Sunil in particular is my favourite speaker,
he’s really funny. His name reminds of the movie Life of Pi (of course his name is Pai, not Pi).&lt;/p&gt;

&lt;p&gt;My picks:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Lee Byron&lt;/b&gt; - released &lt;a href=&quot;https://facebook.github.io/relay/docs/relay-modern.html&quot; target=&quot;_blank&quot;&gt;Relay Modern v1.0&lt;/a&gt; 
live on stage. Relay Modern now supports static queries, client side only fields and subscriptions. 
Client side only fields mean that you can use relay to replace redux. Relay classic will still be supported in npm under
react-relay/classic.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Sunil Pai&lt;/b&gt; - author of glamour, glam and rakt. Rakt is an ambitious project which aims to umm do everything. By everything I mean
taking care of code splitting, data fetching, inline styling (via glamour) and more. It is still not finished yet, so check
&lt;a href=&quot;https://github.com/threepointone/rakt&quot; target=&quot;_blank&quot;&gt;Sunil’s page&lt;/a&gt; often. Sunil is my favourite speaker at the conference, he’s
engaging, impromptu and funny. All ingredients for a captivating talk.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Andrew Clarke&lt;/b&gt; - talks about React Fiber which will be released with React 16 at the end of the year. He also
briefly talked about react portals, which are components which don’t quite fit in the dom tree like modals
and overlays.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Sarah Drasner&lt;/b&gt; - shows really cool css animations/transforms using &lt;a href=&quot;https://greensock.com/get-started-js&quot; target=&quot;_blank&quot;&gt;GreenSock&lt;/a&gt;. 
It’s so cool and easy to use.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Wix lightning talk&lt;/b&gt; - introduces &lt;a href=&quot;https://github.com/wix/detox&quot; target=&quot;_blank&quot;&gt;detox&lt;/a&gt; which is a functional 
testing framework for react native. It’s super cool! It does grey box e2e testing of your react native apps automatically and it’s super fast!
If you use react native you must check it out.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Apollo lightning talk&lt;/b&gt; - Apollo has released a &lt;a href=&quot;https://github.com/apollographql/apollo-client-devtools&quot; target=&quot;_blank&quot;&gt;chrome devtool plugin&lt;/a&gt;
for graphql. It runs graphiql in chrome devtools! It also has a query inspector and a store inspector. Check it out!&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Expo lightning talk&lt;/b&gt; - Expo has created a playground for react native at &lt;a href=&quot;http://snack.expo.io&quot; target=&quot;_blank&quot;&gt;snack.expo.io&lt;/a&gt;.
You can run your react native code on the web without the simulator! It’s like jsfiddle for react native.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Sasha Aickin&lt;/b&gt; - talks about streaming react dom to the client in chunks to boost performance. This involves chunk rendering, which is a
technique involving breaking up a page into different chunks, each with its own html, js, css and data. Each chunk
gets flushed to the client side separately, increasing parallelism and hence performance. Check out his github package 
&lt;a href=&quot;https://github.com/aickin/react-dom-stream&quot; target=&quot;_blank&quot;&gt;react-dom-stream&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;social-insights&quot;&gt;Social Insights&lt;/h2&gt;
&lt;p&gt;Perhaps the best lessons I learnt from the conference are not from the speakers, but from the people I met. There
were many like me, all keen to share their views, opinions and experience and also to listen. Talking to these
developers gave me a chance to validate some of the assumptions I make in my projects and to see the tools and 
techniques others use in their apps.&lt;/p&gt;

&lt;p&gt;These are some of the people I met and the insights I gathered from them:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Dafeng Guo cofounder of strikingly&lt;/b&gt; - started strikingly with 2 other founders in YCombinator in 2012. They had 0 paying customers
in 2012, now they have over 130 employees and a lot more customers :). I am a user of strikingly and I can’t recommend it enough. He also
showed me strikingly’s latest wechat feature where strikingly websites now are automatically converted to wechat apps. That’s super cool!
&lt;img src=&quot;/assets/images/dafeng.png&quot; alt=&quot;Dafeng&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Griffith Tchen Pan&lt;/b&gt; - works at myworkpapers.com. Started in Gold Coast Australia and now has offices in USA and London. 8 years of
 dedication and commitment to a product pays off. That’s what I learned from him.
 &lt;img src=&quot;/assets/images/griffith.png&quot; alt=&quot;Griffith&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Brian Christensen&lt;/b&gt; Danish guy I met at the workshop. Arguably the smartest guy in Denmark, he knows everything from docker to glam to
elm, and does not have a CI in place at his workplace. Just kidding Brian :). He drinks a lot.
&lt;img src=&quot;/assets/images/brian.png&quot; alt=&quot;Brian&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;It’s not the best organised conference I’ve been for a few reasons.&lt;/p&gt;

&lt;p&gt;Firstly as I mentioned above, some of the speakers weren’t really very engaging. 
It was really tough to keep awake at times. Second the food was really really bad. 
During the workshops, there was no protein whatsoever for lunch. It was only 
salad, quinoa, rice, pasta. Where’s the meat!!?! Or fish??!? Thirdly the cancellation of Dan Abramov was 
disappointing. Even Max Stoiber didn’t stick around to give his presentation (no reason given). 
Maybe they were put off by the food…&lt;/p&gt;

&lt;p&gt;I travelled 26 hours from Sydney Australia, stopping at 3 different countries en route to Paris, 
and then back. Is it worth it? Yes. I definitely won’t forget it. Here are more pics from all
the great people I met. Till next time!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/react_conference_collage.png&quot; alt=&quot;Brian&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="react" />
<category term="europe" />
<category term="conference" />
<category term="paris" />
<category term="france" />
<summary>As I stared at the partially cloudy Parisian sky from my seat at Gare du Nord, I had a chance to reflect on the week that was. 4 days jam packed with javascript and react from morning till night followed by socialising afterwards (my fave), it’s definitely not for the faint-hearted. I admit I was a little overwhelmed by the intensity of the schedule.</summary>
</entry>
<entry>
<title>Change marker image onPress in react-native-maps</title>
<link href="http://reactjunkie.com/react-native-maps-change-marker-image-onpress/" rel="alternate" type="text/html" title="Change marker image onPress in react-native-maps" />
<published>2017-04-25T09:30:00+10:00</published>
<updated>2017-04-25T09:30:00+10:00</updated>
<id>http://reactjunkie.com/react-native-maps-change-marker-image-onpress</id>
<content type="html" xml:base="http://reactjunkie.com/react-native-maps-change-marker-image-onpress/">&lt;p&gt;Recently I started a new pet project which involves maps and markers on ios and android. Of course I started
this new project in react native. I was expecting a somewhat challenging times ahead because it has been
a few months since I last did react native development. The landscape has definitely improved, and I feel
so fortunate to be a javascript developer at this present moment because of awesome tools like react-native
at our disposal. The possibilities are truly endless.&lt;/p&gt;

&lt;p&gt;Airbnb has open sourced &lt;a href=&quot;https://github.com/airbnb/react-native-maps&quot; target=&quot;_blank&quot;&gt;react-native-maps&lt;/a&gt; which 
made it so easy to integrate mapping capabilities with your app. There are steps to follow to set it all up but 
it’s not that hard.&lt;/p&gt;

&lt;p&gt;All the code in this blog are available on &lt;a href=&quot;https://github.com/yusinto/react-native-map-markers&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The problem&lt;/h2&gt;
&lt;p&gt;Need to display custom map markers on react-native-maps. Then, onPress of a 
marker, change that marker image so the user can see it has 
been selected. The problem is there is no direct way to get the ref of 
the selected marker. Even if there is, there is no setImage method to
change the marker image.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The solution&lt;/h2&gt;
&lt;p&gt;Out of the box, there’s already an onPress event handler with MapView.Marker
which is a good starting point. We will use this along with the ref and 
image props (also supported out of the box) to solve our problem.&lt;/p&gt;

&lt;h2 id=&quot;are-you-done-talking-show-me-some-code&quot;&gt;Are you done talking? Show me some code!&lt;/h2&gt;
&lt;p&gt;So first things first, you need to install and link react-native-maps:&lt;/p&gt;

&lt;p&gt;{% highlight shell %}
# stick with 0.13.0 to avoid unresolved issues in ^0.14.0
yarn add react-native-maps@0.13.0
{% endhighlight %}
then link it
{% highlight shell %}
react-native link react-native-maps
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;b&gt;GOTCHA&lt;/b&gt; react-native-maps requires babel-plugin-module-resolver as well
otherwise you’ll get this error: Unknown plugin module-resolver. This is a bug
which should be fixed in a later version.&lt;/p&gt;

&lt;p&gt;{% highlight shell %}
yarn add babel-plugin-module-resolver
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Then we can write some code to render a basic map like this:&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
import React, { Component } from ‘react’;
import {AppRegistry, StyleSheet, View} from ‘react-native’;
import MapView from ‘react-native-maps’;&lt;/p&gt;

&lt;p&gt;export default class MapMarkers extends Component {
  state = {
    region: {
      latitude: 1,
      longitude: 1,
      latitudeDelta: 0.0043, // hardcode zoom levels just for example
      longitudeDelta: 0.0034,
    },
  };&lt;/p&gt;

&lt;p&gt;componentDidMount() {
    navigator.geolocation.getCurrentPosition(
      position =&amp;gt; this.setState({
        region: {
          …this.state.region,
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        }
      }),
      error =&amp;gt; alert(JSON.stringify(error)), {
        enableHighAccuracy: true,
        timeout: 20000,
        maximumAge: 1000
      }
    );
  }&lt;/p&gt;

&lt;p&gt;// note that you need to style the map, otherwise you’ll get
  // a blank screen
  render() {
    return (
      &amp;lt;View style={styles.root}&amp;gt;
        &amp;lt;MapView style={styles.map}
                 showsUserLocation={true}
                 followsUserLocation={true}
                 initialRegion={this.state.region}
        /&amp;gt;
      &amp;lt;/View&amp;gt;
    );
  }
}&lt;/p&gt;

&lt;p&gt;const styles = StyleSheet.create({
  root: {
    flex: 1,
    justifyContent: ‘center’,
    alignItems: ‘center’,
  },
  map: {
    position: ‘absolute’,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
});&lt;/p&gt;

&lt;p&gt;AppRegistry.registerComponent(‘mapMarkers’, () =&amp;gt; MapMarkers);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;ios-simulator-setup&quot;&gt;iOS Simulator Setup&lt;/h2&gt;
&lt;p&gt;Before you run this in the simulator, you’ll need to set a custom location
in the ios simulator. We’ll only be demoing on ios only for this blog.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simulator_location_menu.png&quot; alt=&quot;Simulator Location Menu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Set the custom location to Cafe Sydney -33.861924, 151.210891. If you haven’t
been, you have to! It’s an awesome restaurant!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/custom_location.png&quot; alt=&quot;Set Custom Location&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;run-the-project&quot;&gt;Run the project&lt;/h2&gt;

&lt;p&gt;{% highlight shell %}
react-native run-ios
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;You should see a map view with the user location set to Cafe Sydney in Australia.
Now let’s add a few markers.&lt;/p&gt;

&lt;p&gt;{% highlight js%}
// Add these at the top of the file, straight after the imports
const RESTAURANTS = [
  {
    key: ‘Cafe Sydney’,
    title: ‘Cafe Sydney’,
    description: ‘Customs House, 31 Alfred St, Sydney NSW 2000’,
    latLong: {
      latitude: -33.861924,
      longitude: 151.210891,
    },
  },
  {
    key: ‘Four Frogs Creperie’,
    title: ‘Four Frogs Creperie’,
    description: ‘1 Macquarie Pl, Sydney NSW 2000’,
    latLong: {
      latitude: -33.861755,
      longitude: 151.209941,
    },
  },
  {
    key: ‘Tapavino’,
    title: ‘Tapavino’,
    description: ‘6 Bulletin Pl, Sydney NSW 2000’,
    latLong: {
      latitude: -33.862512,
      longitude: 151.209490,
    },
  },
];&lt;/p&gt;

&lt;p&gt;// then modify your render method to look like this
  render() {
    return (
      &amp;lt;View style={styles.root}&amp;gt;
        &amp;lt;MapView style={styles.map}
                 showsUserLocation={true}
                 followsUserLocation={true}
                 initialRegion={this.state.region}
        &amp;gt;
          {
            RESTAURANTS.map((m, i) =&amp;gt;
              &amp;lt;MapView.Marker
                coordinate={m.latLong}
                title={m.title}
                description={m.description}
                key={&lt;code class=&quot;highlighter-rouge&quot;&gt;marker-${i}&lt;/code&gt;}
              /&amp;gt;
            )
          }
        &amp;lt;/MapView&amp;gt;
      &amp;lt;/View&amp;gt;
    );
  }
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;You should see 3 markers on the map. Now we want to use a custom image 
for our marker. MapView has an image prop we can set so that’s easy. 
Then onPress of a marker, we want to change this image to a different 
one to show the user that it has been selected. Again MapView has an 
onPress prop which we can use to set a custom callback when a marker gets pressed.&lt;/p&gt;

&lt;p&gt;Here’s the trick, onpress of a marker, we have to pass the index of the selected
marker and save that to state. Then on the image prop, we can inspect
if the marker being rendered matches the selected index in state, and use
a different image if so.&lt;/p&gt;

&lt;p&gt;{% highlight js%}
// At the top of the file after imports, we require our marker images
const marker = require(‘./assets/images/marker.png’);
const selectedMarker = require(‘./assets/images/marker-selected.png’);&lt;/p&gt;

&lt;p&gt;// Then in our class
onPressMarker(e, index) {
    this.setState({selectedMarkerIndex: index});
}&lt;/p&gt;

&lt;p&gt;// Then in our render method, we specify onPress and image props.
// For brevity, I only include the relevant bits of code here
RESTAURANTS.map((m, i) =&amp;gt;
  &amp;lt;MapView.Marker
    coordinate={m.latLong}
    title={m.title}
    description={m.description}
    key={&lt;code class=&quot;highlighter-rouge&quot;&gt;marker-${i}&lt;/code&gt;}
    onPress={(e) =&amp;gt; this.onPressMarker(e, i)}
    image={this.state.selectedMarkerIndex === i ? selectedMarker : marker} // this is the crux of the blog
  /&amp;gt;
)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;That’s it!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Check out the &lt;a href=&quot;https://github.com/yusinto/react-native-map-markers&quot; target=&quot;_blank&quot;&gt;complete code&lt;/a&gt; on 
github. Let me know if this helps!&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="react" />
<category term="native" />
<category term="maps" />
<category term="change" />
<category term="marker" />
<category term="image" />
<category term="onpress" />
<summary>Recently I started a new pet project which involves maps and markers on ios and android. Of course I startedthis new project in react native. I was expecting a somewhat challenging times ahead because it has beena few months since I last did react native development. The landscape has definitely improved, and I feelso fortunate to be a javascript developer at this present moment because of awesome tools like react-nativeat our disposal. The possibilities are truly endless.</summary>
</entry>
</feed>
