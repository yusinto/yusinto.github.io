<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.0.3">Jekyll</generator>
<link href="http://www.reactjunkie.com/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://www.reactjunkie.com/" rel="alternate" type="text/html" />
<updated>2016-04-02T18:06:22+11:00</updated>
<id>http://www.reactjunkie.com/</id>
<title>React Junkie</title>
<entry>
<title>Step 3 to React: Speed dev with hot module replacement</title>
<link href="http://www.reactjunkie.com/step-three-to-react-speed-dev-with-hot-module-replacement/" rel="alternate" type="text/html" title="Step 3 to React: Speed dev with hot module replacement" />
<published>2016-04-02T17:45:00+11:00</published>
<updated>2016-04-02T17:45:00+11:00</updated>
<id>http://www.reactjunkie.com/step-three-to-react-speed-dev-with-hot-module-replacement</id>
<content type="html" xml:base="http://www.reactjunkie.com/step-three-to-react-speed-dev-with-hot-module-replacement/">&lt;p&gt;In the &lt;a href=&quot;http://www.reactjunkie.com/step-two-to-react-webpack-and-react/&quot;&gt;previous post&lt;/a&gt; we started writing react code
and that was cool. However having to restart the app and refresh the browser everytime we make a change is a pain. 
There must be a better way to optimise our dev/debug cycle.&lt;/p&gt;

&lt;p&gt;And yes there is. Enter react hot module replacement or hmr created by &lt;a href=&quot;https://github.com/gaearon&quot;&gt;Dan Abramov&lt;/a&gt; the creator of redux. Hmr is a much much better
“version” of liveReload. You don’t need to inject a script tag into your code and there is no browser refresh. When you make
changes to your code, they simply appear in the browser like magic without reload.&lt;/p&gt;

&lt;p&gt;This is a short post just to get hmr working so let’s dive straight into the code now and I’ll explain things along the way.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-31-install-transforms-and-webpack-middlewares&quot;&gt;Step 3.1: Install transforms and webpack middlewares&lt;/h2&gt;
&lt;p&gt;There are 6 packages we need to install:&lt;/p&gt;

&lt;p&gt;{% highlight raw %}
npm install –save-dev babel-plugin-react-transform react-transform-hmr react-transform-catch-errors redbox-react webpack-dev-middleware webpack-hot-middleware
{% endhighlight %}&lt;/p&gt;

&lt;h4 id=&quot;babel-plugin-react-transform&quot;&gt;babel-plugin-react-transform&lt;/h4&gt;

&lt;p&gt;This modifies your react components by applying all the transforms we configure in .babelrc.&lt;/p&gt;

&lt;h4 id=&quot;react-transform-hmr-react-transform-catch-errors&quot;&gt;react-transform-hmr, react-transform-catch-errors&lt;/h4&gt;
&lt;p&gt;The babel plugin above applies these transforms to our react components. Each transform modifies your react component in a specific way:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;react-transform-hmr&lt;/b&gt; - This transform enables hot reloading of components
&lt;b&gt;react-transform-catch-errors&lt;/b&gt; - This transform catches errors inside the render() method and renders that error instead of your component.&lt;/p&gt;

&lt;h4 id=&quot;redbox-react&quot;&gt;redbox-react&lt;/h4&gt;
&lt;p&gt;Used by react-transform-catch-errors to display errors in a red screen of death in the browser.&lt;/p&gt;

&lt;h4 id=&quot;webpack-dev-middleware-webpack-hot-middleware&quot;&gt;webpack-dev-middleware, webpack-hot-middleware&lt;/h4&gt;
&lt;p&gt;&lt;b&gt;webpack-dev-middleware&lt;/b&gt; - bundles our js file on the fly, stores it in memory and serves it&lt;/p&gt;

&lt;p&gt;&lt;b&gt;webpack-hot-middleware&lt;/b&gt; - enables hot reloading using webpack-dev-middleware above&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-32-configure-babel&quot;&gt;Step 3.2: Configure babel&lt;/h2&gt;

&lt;p&gt;Your .babelrc file should look like this:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
{
    “presets”: [“es2015”, “react”],
    “plugins”: [
        [“react-transform”, {
            “transforms”: [{
                “transform”: “react-transform-hmr”,
                “imports”: [“react”],
                “locals”: [“module”]
            }, {
                “transform”: “react-transform-catch-errors”,
                “imports”: [“react”, “redbox-react”]
            }]
        }]
    ]
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This is the configuration that uses the transform packages above. In short, we instruct the
react-transform plugin to apply 2 transforms: the hmr and catch-errors transforms to our react 
components. In simple terms, transforms are just functions that accepts a react component as input and modifies it. For 
example, &lt;b&gt;&lt;i&gt;react-transform-catch-errors&lt;/i&gt;&lt;/b&gt; adds a try catch block on the original render method to catch exceptions.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-33-configure-webpack&quot;&gt;Step 3.3: Configure webpack&lt;/h2&gt;
&lt;p&gt;Your webpack.config.dev.js should look like this:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
var webpack = require(‘webpack’);
var path = require(‘path’);&lt;/p&gt;

&lt;p&gt;module.exports = {
    // Add webpack-hot-middleware/client to our bundle so our app 
    // subscribes to update notifications from the server
    entry: [‘webpack-hot-middleware/client’, path.join(__dirname, ‘src/client/index’)],
    output: {
        path: path.join(__dirname, ‘dist’),
        filename: ‘bundle.js’,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // Add a publicPath property. This is the path referenced in the 
    // script tag in our html template to our bundle.js. We need 
    // this to configure webpack-dev-middleware in server.js
    publicPath: &#39;/dist/&#39; 
},
module: {
    loaders:[{
        test: /\.jsx?$/,
        loader: &#39;babel&#39;,
        include: path.join(__dirname, &#39;src&#39;)
    }]
},

// Enables hot module replacement in webpack
plugins: [
    new webpack.HotModuleReplacementPlugin()
] }; {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-34-modify-express-app-to-support-hmr&quot;&gt;Step 3.4: Modify express app to support hmr&lt;/h2&gt;
&lt;p&gt;Almost there! Now we need to modify server.js to use webpack dev and hot middlewares.&lt;/p&gt;

&lt;p&gt;{% highlight c# %}
…&lt;/p&gt;

&lt;p&gt;import Webpack from ‘webpack’;
import WebpackConfig from ‘../../webpack.config.dev’;
import WebpackDevMiddleware from ‘webpack-dev-middleware’;
import WebPackHotMiddleware from ‘webpack-hot-middleware’;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;// create a webpack instance from our dev config
const webpackCompiler = Webpack(WebpackConfig);&lt;/p&gt;

&lt;p&gt;// Use webpack dev middleware to bundle our app on the fly and serve it 
// on publicPath. Turn off verbose webpack output in our server console
// by setting noInfo: true
app.use(WebpackDevMiddleware(webpackCompiler, {
    publicPath: WebpackConfig.output.publicPath,
    noInfo: true
}));&lt;/p&gt;

&lt;p&gt;// instruct our webpack instance to use webpack hot middleware
app.use(WebPackHotMiddleware(webpackCompiler));&lt;/p&gt;

&lt;p&gt;// NOTE: delete express static middleware for dist. We don’t need that
// anymore because webpack-dev-middleware serves our bundle.js from memory&lt;/p&gt;

&lt;p&gt;…
{% endhighlight %}&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-35-run-the-app&quot;&gt;Step 3.5: Run the app!&lt;/h2&gt;
&lt;p&gt;If you have been following my &lt;a href=&quot;http://www.reactjunkie.com/step-two-to-react-webpack-and-react/&quot;&gt;previous post&lt;/a&gt; up to this point, 
note that you’ll need to delete the prestart command from package.json. We don’t need that anymore because we are using webpack
dev middleware to bundle our app on the fly.&lt;/p&gt;

&lt;p&gt;If you have the physical /dist/ folder, also delete that because
again webpack dev middleware will serve bundle.js from memory.&lt;/p&gt;

&lt;p&gt;At your root directory run “npm start” and browse to localhost:3000. Then make changes to appComponent.js; maybe change
the h1 text. You’ll see your changes in the browser immediately without refresh.&lt;/p&gt;

&lt;p&gt;Download the complete source code from &lt;a href=&quot;https://github.com/yusinto/reactStep3&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="react" />
<category term="hmr" />
<category term="hot" />
<category term="module" />
<category term="replacement" />
<category term="webpack" />
<category term="babel" />
<summary>In the previous post we started writing react codeand that was cool. However having to restart the app and refresh the browser everytime we make a change is a pain. There must be a better way to optimise our dev/debug cycle.</summary>
</entry>
<entry>
<title>Step 2 to React: Webpack and React</title>
<link href="http://www.reactjunkie.com/step-two-to-react-webpack-and-react/" rel="alternate" type="text/html" title="Step 2 to React: Webpack and React" />
<published>2016-03-30T21:25:00+11:00</published>
<updated>2016-03-30T21:25:00+11:00</updated>
<id>http://www.reactjunkie.com/step-two-to-react-webpack-and-react</id>
<content type="html" xml:base="http://www.reactjunkie.com/step-two-to-react-webpack-and-react/">&lt;p&gt;If you haven’t read my &lt;a href=&quot;http://www.reactjunkie.com/step-one-to-react-es-6-and-express/&quot;&gt;previous post&lt;/a&gt;, 
it might be a good idea to have a quick read before reading this one. We’ll build this example based on that last post.
Let’s get into it!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-21-install-webpack-babel-and-react&quot;&gt;Step 2.1: Install webpack, babel and react&lt;/h2&gt;

&lt;p&gt;{% highlight raw %}
npm install –save-dev webpack babel-loader
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight raw %}
npm install –save react react-dom babel-preset-react
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;We use webpack to bundle all our javascript code into a single file. We then include this bundled file 
in a script tag in our html just like any other js file. This single file alone will be sufficient to run our app in the browser.&lt;/p&gt;

&lt;p&gt;Our code is in es6 and jsx (we’ll talk about jsx in detail a bit later) which are not (yet) natively understood by browsers. So
we have to transpile (short for transform and compile) it into pure javascript which are understood by all browsers. We use
babel to perform this transpilation.&lt;/p&gt;

&lt;p&gt;react and react-dom are core react modules required to write react apps. babel-preset-react instructs babel (both
babel-register and babel-loader) to transpile jsx into pure javascript.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-22-configure-webpack&quot;&gt;Step 2.2: Configure webpack&lt;/h2&gt;
&lt;p&gt;Create a new file called webpack.config.dev.js at the root directory of your project. The file contents should look like this:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
var webpack = require(‘webpack’);
var path = require(‘path’);&lt;/p&gt;

&lt;p&gt;module.exports = {
    entry: [path.join(__dirname, ‘src/client/index’)],
    output: {
        path: path.join(__dirname, ‘dist’),
        filename: ‘bundle.js’
    },
    module: {
        loaders:[{
            test: /.jsx?$/,
            loader: ‘babel’,
            include: path.join(__dirname, ‘src’)
        }]
    }
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;There are 3 main parts to this config:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;entry: tells webpack to start bundling from this file&lt;/li&gt;
&lt;li&gt;output: write the resultant bundled file to the dist folder at root&lt;/li&gt;
&lt;li&gt;module.loaders: For all js or jsx files under src folder, use babel-loader to transpile those files prior to bundling&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-23-add-a-build-command-to-packagejson&quot;&gt;Step 2.3: Add a build command to package.json&lt;/h2&gt;

&lt;p&gt;In your package.json, add a scripts.prestart command. This is a natively supported npm command, just like start.
When you run npm start, the prestart command will always get executed first, then the start command, followed by a
poststart command which we don’t use here.&lt;/p&gt;

&lt;p&gt;In prestart, we tell npm to run webpack with the config file above essentially
bundling our app prior to running it.&lt;/p&gt;

&lt;p&gt;{% highlight js %}
{
…
      “scripts”: {
        “prestart”: “webpack –config webpack.config.dev.js –progress”,
        “start”: “node src/server/index.js”,
      }
…
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;When the prestart command completes, a bundle.js file should exist in the dist folder.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-24-write-some-react-code&quot;&gt;Step 2.4: Write some react code&lt;/h2&gt;
&lt;p&gt;Finally we get to write some react code! This is the meatiest part, so it’s a bit longer than the other sections, but
it’s worth it. Let’s create two new files:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;src/common/component/appComponent.js&lt;/li&gt;
    &lt;li&gt;src/client/index.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note about directory structure: All my code are in a src folder to separate it from other elements of the project
like node_modules and dist. This allows me to target only src for transpilation in my webpack build. Under src, my files
are further organised into client, server and common.&lt;/p&gt;

&lt;p&gt;So what’s in common? This is in preparation for building a universal
app (also known as isomorphic app) where the code being run on the client and server are one and the same ergo common
code. But we’ll talk more about this in a later post.&lt;/p&gt;

&lt;p&gt;If you come from an OO background like me, you should be familiar with the syntax here.&lt;/p&gt;

&lt;h5 id=&quot;appcomponentjs&quot;&gt;appComponent.js&lt;/h5&gt;
&lt;p&gt;{% highlight C# %}
/*
 Import react’s default module and assign it to a variable named React. 
 Additionally we also import the Component module and assign it to a 
 variable named Component.
*/
import React, {Component} from ‘react’;&lt;/p&gt;

&lt;p&gt;/*
 Subclass React.Component and implement the render method. This method 
 must return a single child element. A react component at minimum must 
 implement the render method. Also set this class as the default export 
 of this file so we can import it in other files.
*/
export default class App extends Component {
    render() {
        return (
            // Nooo this looks like inline html! Are we back in the land
            // of classic asp/php? Short answer is no we are not. See 
            // below for details.
            &amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;Hello world in React!&amp;lt;/h1&amp;gt;
                &amp;lt;p&amp;gt;
                    The time now is { (new Date()).toLocaleString() }
                &amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;It might look like we are writing literal html strings like old school asp/php, 
but under the bonnet these are shorthand syntax to generate ReactElements.&lt;/p&gt;

&lt;p&gt;A ReactElement is the primary basic type in React which constitutes the virtual DOM. In essence, you are
writing virtual DOM. It’s called virtual because it’s not the real DOM. React keeps an in-memory copy
of this “html” ergo virtual dom and only flushes changes to the real DOM in the browser if there is a props or state
change. We’ll talk about props and state more in later posts.&lt;/p&gt;

&lt;p&gt;For now, just understand that you are writing a html-like syntax called jsx which becomes part of the virtual dom.&lt;/p&gt;

&lt;h5 id=&quot;indexjs&quot;&gt;index.js&lt;/h5&gt;
&lt;p&gt;{% highlight C# %}
// Import the render method from react-dom so we can mount our 
// component onto an html element
import React from ‘react’;
import {render} from ‘react-dom’;
import App from ‘../common/component/appComponent’;&lt;/p&gt;

&lt;p&gt;// This is the entry point into our react app on the client side. Again 
// we use jsx to create our ReactElement and mount it onto a div called 
// reactDiv on the html template.
render(&lt;app&gt;&lt;/app&gt;, document.getElementById(‘reactDiv’));
{% endhighlight %}&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-25-modify-express-to-serve-react&quot;&gt;Step 2.5: Modify express to serve react&lt;/h2&gt;
&lt;p&gt;Almost there! Now we need to modify server.js to serve a html page with a script reference to our dist/bundled.js generated by webpack.&lt;/p&gt;

&lt;p&gt;We also need to add an express static middleware to serve that static bundle.js file. A middleware is just code that executes
between a request and a response. In this example, a GET request comes in from the client asking for dist/bundled.js. Our
middleware matches the route and executes our code. We use express’ built-in static middleware so we get this for free.&lt;/p&gt;

&lt;p&gt;{% highlight c# %}&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;// This is our html template that contains our target mounting 
// div id=”reactDiv”. Also note the script reference to /dist/bundle.js.
const htmlString = &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Webpack and React&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;reactDiv&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/dist/bundle.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;// Use express’ built-in static middleware to serve static files in 
// the dist folder
app.use(‘/dist’, Express.static(‘dist’));&lt;/p&gt;

&lt;p&gt;…
{% endhighlight %}&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-26-run-the-app&quot;&gt;Step 2.6: Run the app!&lt;/h2&gt;
&lt;p&gt;At your root directory run “npm start” and browse to localhost:3000 to see the output.
Download the complete source code from &lt;a href=&quot;https://github.com/yusinto/reactStep2&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;
</content>
<category term="react" />
<category term="webpack" />
<category term="babel" />
<summary>If you haven’t read my previous post, it might be a good idea to have a quick read before reading this one. We’ll build this example based on that last post.Let’s get into it!</summary>
</entry>
<entry>
<title>Step 1 to React: Using es6 with Express</title>
<link href="http://www.reactjunkie.com/step-one-to-react-es-6-and-express/" rel="alternate" type="text/html" title="Step 1 to React: Using es6 with Express" />
<published>2016-03-27T17:48:00+11:00</published>
<updated>2016-03-27T17:48:00+11:00</updated>
<id>http://www.reactjunkie.com/step-one-to-react-es-6-and-express</id>
<content type="html" xml:base="http://www.reactjunkie.com/step-one-to-react-es-6-and-express/">&lt;p&gt;I came from a .Net background but I realised quickly how powerful and easy node is and I love it. The advent of es6 has
bridged the gap even further. The introduction of arrow functions, classes and destructuring really make node programming
 that much more enjoyable and fun.&lt;/p&gt;

&lt;p&gt;Enough of my rant! Let’s get to the point. This post is part one of a series of posts about react and the things I
 encountered in the process of learning it. One of the first steps that often get overlooked is how to get es6 to work
 with node on the server side. To me this is a very important step because I want my app to be in es6 as much as possible.&lt;/p&gt;

&lt;p&gt;Note that this is a very basic example of a node app running es6 without any react elements. In my next post, I will
 add react. The following posts will gradually include react router, relay, hot module replacement (hmr), 
 redux, foundation (sass) and many other goodies!&lt;/p&gt;

&lt;p&gt;But first thing first&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-11-install-babel&quot;&gt;Step 1.1: Install babel&lt;/h2&gt;
&lt;p&gt;You’ll need to install express, babel-express and babel-preset-es2015:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
npm install express babel-register babel-preset-es2015 –save
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Where express is the standard web framework for node, babel-register will compile every file that is require’d with babel and
babel-preset-es2015 tells babel to transpile es6 code to es5.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-12-configure-babel---add-a-babelrc-file&quot;&gt;Step 1.2: Configure babel - add a .babelrc file&lt;/h2&gt;
&lt;p&gt;Create a new file called .babelrc at the root directory of your project. The file contents should look like this:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
{
    “presets”: [“es2015”]
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This configures babel to transpile es6 code to es5.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-13-configure-an-entry-point-in-packagejson&quot;&gt;Step 1.3: Configure an entry point in package.json&lt;/h2&gt;

&lt;p&gt;In your package.json, add a scripts/start command which tells npm what to do when you run “npm start” in the command line:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
{
…
      “scripts”: {
        “start”: “node src/server/index.js”,
      }
…
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This tells npm to execute src/server/index.js when you run “npm start” at your root project folder. In this case, index.js 
is the entry point to your app. The contents of this file should look like this:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
require(‘babel-register’);
require(‘./server’);
{% endhighlight %}&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-14-write-es6-code&quot;&gt;Step 1.4: Write es6 code&lt;/h2&gt;
&lt;p&gt;The file server.js contains all your es6 code for your app. It should look like this:&lt;/p&gt;

&lt;p&gt;{% highlight js %}
import Express from ‘express’;&lt;/p&gt;

&lt;p&gt;const PORT = 3000;
const app = Express();&lt;/p&gt;

&lt;p&gt;app.use((req, res) =&amp;gt; {
    res.end(‘hello world!’);
});&lt;/p&gt;

&lt;p&gt;app.listen(PORT, () =&amp;gt; {
    console.log(&lt;code class=&quot;highlighter-rouge&quot;&gt;Listening at ${PORT}&lt;/code&gt;);
});
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Here we use import statements in place of the classic require statements, const keyword instead of var, 
arrow functions instead of inline function declarations and es6 template strings instead of string concatenations.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;step-15-run-your-app&quot;&gt;Step 1.5: Run your app!&lt;/h2&gt;
&lt;p&gt;Run&lt;/p&gt;

&lt;p&gt;{% highlight js %}
npm start
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;at your root directory and browse to localhost:3000 to see the output of your app. Download the complete source code from
 &lt;a href=&quot;https://github.com/yusinto/reactStep1&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

</content>
<category term="react" />
<category term="es6" />
<category term="express" />
<summary>I came from a .Net background but I realised quickly how powerful and easy node is and I love it. The advent of es6 hasbridged the gap even further. The introduction of arrow functions, classes and destructuring really make node programming that much more enjoyable and fun.</summary>
</entry>
</feed>
